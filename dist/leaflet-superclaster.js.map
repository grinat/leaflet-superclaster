{"version":3,"sources":["webpack://amd/webpack/bootstrap","webpack://amd/external \"L\"","webpack://amd/./src/SuperclusterWorker.js","webpack://amd/./src/SuperclusterGroup.js","webpack://amd/./node_modules/worker-loader/dist/workers/InlineWorker.js","webpack://amd/./src/supercluster.scss?cb2e"],"names":["module","exports","require","__webpack_public_path__","SuperclusterGroup","L","extend","options","clusterIconFunc","pointIconFunc","optimizeRedraw","appendChildIdsToCluster","showClustersOnMaxZoom","showedSubClusterMultiplier","showMarkersBeforeMaxZoom","bboxIncreasePer","moveToLastKept","moveToLastKeptBoundsMultiplier","clusterzIndexOffset","pointzIndexOffset","maxMarkersInClusterOnOnePoint","animated","spiderfyDistanceMultiplier","log","legsStyle","weight","color","supercluster","radius","extent","minZoom","maxZoom","_geoJsonLayer","_worker","_map","_keptPointIds","_initWorker","SuperclusterWorker","onmessage","d","_onWorkerMessage","onerror","e","fire","_createGeoJsonLayer","pointToLayer","feature","latlng","zIndexOffset","properties","cluster","icon","on","_geoJsonClick","layer","_checkAndUnKeepPoint","_checkAndKeepPoint","_addClassToIcon","_deleteLayerFromGeoJsonLayer","l","_recursiveRemoveAllOpenedClusterLayer","removeLayer","isMaxZoom","getZoom","getMaxZoom","clusterId","cluster_id","clusterOpened","_openedClusterLayer","_closeCluster","_sendMessage","_onPointClick","parentLayer","_zoomEnd","_clusteringData","_moveEnd","bounds","getBounds","bbox","getWest","getSouth","getEast","getNorth","zoom","keptPointIds","action","data","message","postMessage","loadGeoJsonData","featuresOrFutureCollection","features","Array","isArray","subCluster","keepPoint","id","unKeepPoint","indexOf","console","push","warn","length","filter","v","layers","getLayers","lastId","find","_getDistanceFromMapCenter","distMin","getLatLng","toBounds","lastInView","contains","setView","getCenter","group","time","_drawItems","_expansionZoom","_openCluster","timeEnd","groupEnd","currentZoom","len","forEach","addData","addMarkerFeaturesMap","addClustersFeaturesMap","gLen","i","composite_id","lLen","_removeOrUpdateLayer","Object","values","featureIdMap","propKey","setLatLng","geometry","coordinates","point_count","setIcon","_updateMarkersInOpenedClusterLayer","_clusterIconFunc","className","html","iconSize","iconAnchor","_pointIconFunc","initialize","opt","hasOwnProperty","assign","onAdd","map","getMinZoom","addTo","onRemove","off","clearLayers","_removeClassFromIcon","_updateMarkersInCluster","legs","subLayers","subLen","_segmentFeaturesForLayer","segmentalFeatures","featuresForCreate","_createMarkersInCluster","style","_toggleSubCluster","subL","_closeSubCluster","_openSubCluster","center","centerEast","lat","distCenterToEast","distanceTo","centerNorth","lng","distCenterToNorth","parentCenter","_segmentFeatures","_getLegsForMarkersInCluster","sort","a","b","subClusterCount","Math","ceil","_createSpiral","subClusters","featuresInSubCluster","slice","type","isSubCluster","spiralLengthFactor","spiralFootSeparation","spiralLengthStart","centerPt","latLngToLayerPoint","pi2","PI","count","separation","lengthFactor","legLength","angle","p","coords","newFeatures","x","cos","y","sin","_round","layerPointToLatLng","parentCenterGeometry","name","_icon","classList","add","remove"],"mappings":"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","file":"leaflet-superclaster.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","module.exports = L;","module.exports = function() {\n  return require(\"!!/home/grinat/WebstormProjects/leaflet-superclaster/node_modules/worker-loader/dist/workers/InlineWorker.js\")(\"/******/ (function(modules) { // webpackBootstrap\\n/******/ \\t// The module cache\\n/******/ \\tvar installedModules = {};\\n/******/\\n/******/ \\t// The require function\\n/******/ \\tfunction __webpack_require__(moduleId) {\\n/******/\\n/******/ \\t\\t// Check if module is in cache\\n/******/ \\t\\tif(installedModules[moduleId]) {\\n/******/ \\t\\t\\treturn installedModules[moduleId].exports;\\n/******/ \\t\\t}\\n/******/ \\t\\t// Create a new module (and put it into the cache)\\n/******/ \\t\\tvar module = installedModules[moduleId] = {\\n/******/ \\t\\t\\ti: moduleId,\\n/******/ \\t\\t\\tl: false,\\n/******/ \\t\\t\\texports: {}\\n/******/ \\t\\t};\\n/******/\\n/******/ \\t\\t// Execute the module function\\n/******/ \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n/******/\\n/******/ \\t\\t// Flag the module as loaded\\n/******/ \\t\\tmodule.l = true;\\n/******/\\n/******/ \\t\\t// Return the exports of the module\\n/******/ \\t\\treturn module.exports;\\n/******/ \\t}\\n/******/\\n/******/\\n/******/ \\t// expose the modules object (__webpack_modules__)\\n/******/ \\t__webpack_require__.m = modules;\\n/******/\\n/******/ \\t// expose the module cache\\n/******/ \\t__webpack_require__.c = installedModules;\\n/******/\\n/******/ \\t// define getter function for harmony exports\\n/******/ \\t__webpack_require__.d = function(exports, name, getter) {\\n/******/ \\t\\tif(!__webpack_require__.o(exports, name)) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\\n/******/ \\t\\t}\\n/******/ \\t};\\n/******/\\n/******/ \\t// define __esModule on exports\\n/******/ \\t__webpack_require__.r = function(exports) {\\n/******/ \\t\\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\\n/******/ \\t\\t}\\n/******/ \\t\\tObject.defineProperty(exports, '__esModule', { value: true });\\n/******/ \\t};\\n/******/\\n/******/ \\t// create a fake namespace object\\n/******/ \\t// mode & 1: value is a module id, require it\\n/******/ \\t// mode & 2: merge all properties of value into the ns\\n/******/ \\t// mode & 4: return value when already ns object\\n/******/ \\t// mode & 8|1: behave like require\\n/******/ \\t__webpack_require__.t = function(value, mode) {\\n/******/ \\t\\tif(mode & 1) value = __webpack_require__(value);\\n/******/ \\t\\tif(mode & 8) return value;\\n/******/ \\t\\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\\n/******/ \\t\\tvar ns = Object.create(null);\\n/******/ \\t\\t__webpack_require__.r(ns);\\n/******/ \\t\\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\\n/******/ \\t\\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\\n/******/ \\t\\treturn ns;\\n/******/ \\t};\\n/******/\\n/******/ \\t// getDefaultExport function for compatibility with non-harmony modules\\n/******/ \\t__webpack_require__.n = function(module) {\\n/******/ \\t\\tvar getter = module && module.__esModule ?\\n/******/ \\t\\t\\tfunction getDefault() { return module['default']; } :\\n/******/ \\t\\t\\tfunction getModuleExports() { return module; };\\n/******/ \\t\\t__webpack_require__.d(getter, 'a', getter);\\n/******/ \\t\\treturn getter;\\n/******/ \\t};\\n/******/\\n/******/ \\t// Object.prototype.hasOwnProperty.call\\n/******/ \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n/******/\\n/******/ \\t// __webpack_public_path__\\n/******/ \\t__webpack_require__.p = \\\"/\\\";\\n/******/\\n/******/\\n/******/ \\t// Load entry module and return exports\\n/******/ \\treturn __webpack_require__(__webpack_require__.s = 0);\\n/******/ })\\n/************************************************************************/\\n/******/ ([\\n/* 0 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n__webpack_require__.r(__webpack_exports__);\\n\\n// CONCATENATED MODULE: ./node_modules/kdbush/src/sort.js\\n\\nfunction sortKD(ids, coords, nodeSize, left, right, depth) {\\n    if (right - left <= nodeSize) return;\\n\\n    const m = (left + right) >> 1;\\n\\n    sort_select(ids, coords, m, left, right, depth % 2);\\n\\n    sortKD(ids, coords, nodeSize, left, m - 1, depth + 1);\\n    sortKD(ids, coords, nodeSize, m + 1, right, depth + 1);\\n}\\n\\nfunction sort_select(ids, coords, k, left, right, inc) {\\n\\n    while (right > left) {\\n        if (right - left > 600) {\\n            const n = right - left + 1;\\n            const m = k - left + 1;\\n            const z = Math.log(n);\\n            const s = 0.5 * Math.exp(2 * z / 3);\\n            const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\\n            const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\\n            const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\\n            sort_select(ids, coords, k, newLeft, newRight, inc);\\n        }\\n\\n        const t = coords[2 * k + inc];\\n        let i = left;\\n        let j = right;\\n\\n        swapItem(ids, coords, left, k);\\n        if (coords[2 * right + inc] > t) swapItem(ids, coords, left, right);\\n\\n        while (i < j) {\\n            swapItem(ids, coords, i, j);\\n            i++;\\n            j--;\\n            while (coords[2 * i + inc] < t) i++;\\n            while (coords[2 * j + inc] > t) j--;\\n        }\\n\\n        if (coords[2 * left + inc] === t) swapItem(ids, coords, left, j);\\n        else {\\n            j++;\\n            swapItem(ids, coords, j, right);\\n        }\\n\\n        if (j <= k) left = j + 1;\\n        if (k <= j) right = j - 1;\\n    }\\n}\\n\\nfunction swapItem(ids, coords, i, j) {\\n    swap(ids, i, j);\\n    swap(coords, 2 * i, 2 * j);\\n    swap(coords, 2 * i + 1, 2 * j + 1);\\n}\\n\\nfunction swap(arr, i, j) {\\n    const tmp = arr[i];\\n    arr[i] = arr[j];\\n    arr[j] = tmp;\\n}\\n\\n// CONCATENATED MODULE: ./node_modules/kdbush/src/range.js\\n\\nfunction range(ids, coords, minX, minY, maxX, maxY, nodeSize) {\\n    const stack = [0, ids.length - 1, 0];\\n    const result = [];\\n    let x, y;\\n\\n    while (stack.length) {\\n        const axis = stack.pop();\\n        const right = stack.pop();\\n        const left = stack.pop();\\n\\n        if (right - left <= nodeSize) {\\n            for (let i = left; i <= right; i++) {\\n                x = coords[2 * i];\\n                y = coords[2 * i + 1];\\n                if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[i]);\\n            }\\n            continue;\\n        }\\n\\n        const m = Math.floor((left + right) / 2);\\n\\n        x = coords[2 * m];\\n        y = coords[2 * m + 1];\\n\\n        if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[m]);\\n\\n        const nextAxis = (axis + 1) % 2;\\n\\n        if (axis === 0 ? minX <= x : minY <= y) {\\n            stack.push(left);\\n            stack.push(m - 1);\\n            stack.push(nextAxis);\\n        }\\n        if (axis === 0 ? maxX >= x : maxY >= y) {\\n            stack.push(m + 1);\\n            stack.push(right);\\n            stack.push(nextAxis);\\n        }\\n    }\\n\\n    return result;\\n}\\n\\n// CONCATENATED MODULE: ./node_modules/kdbush/src/within.js\\n\\nfunction within(ids, coords, qx, qy, r, nodeSize) {\\n    const stack = [0, ids.length - 1, 0];\\n    const result = [];\\n    const r2 = r * r;\\n\\n    while (stack.length) {\\n        const axis = stack.pop();\\n        const right = stack.pop();\\n        const left = stack.pop();\\n\\n        if (right - left <= nodeSize) {\\n            for (let i = left; i <= right; i++) {\\n                if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) result.push(ids[i]);\\n            }\\n            continue;\\n        }\\n\\n        const m = Math.floor((left + right) / 2);\\n\\n        const x = coords[2 * m];\\n        const y = coords[2 * m + 1];\\n\\n        if (sqDist(x, y, qx, qy) <= r2) result.push(ids[m]);\\n\\n        const nextAxis = (axis + 1) % 2;\\n\\n        if (axis === 0 ? qx - r <= x : qy - r <= y) {\\n            stack.push(left);\\n            stack.push(m - 1);\\n            stack.push(nextAxis);\\n        }\\n        if (axis === 0 ? qx + r >= x : qy + r >= y) {\\n            stack.push(m + 1);\\n            stack.push(right);\\n            stack.push(nextAxis);\\n        }\\n    }\\n\\n    return result;\\n}\\n\\nfunction sqDist(ax, ay, bx, by) {\\n    const dx = ax - bx;\\n    const dy = ay - by;\\n    return dx * dx + dy * dy;\\n}\\n\\n// CONCATENATED MODULE: ./node_modules/kdbush/src/index.js\\n\\n\\n\\n\\n\\nconst defaultGetX = p => p[0];\\nconst defaultGetY = p => p[1];\\n\\nclass src_KDBush {\\n    constructor(points, getX = defaultGetX, getY = defaultGetY, nodeSize = 64, ArrayType = Float64Array) {\\n        this.nodeSize = nodeSize;\\n        this.points = points;\\n\\n        const IndexArrayType = points.length < 65536 ? Uint16Array : Uint32Array;\\n\\n        const ids = this.ids = new IndexArrayType(points.length);\\n        const coords = this.coords = new ArrayType(points.length * 2);\\n\\n        for (let i = 0; i < points.length; i++) {\\n            ids[i] = i;\\n            coords[2 * i] = getX(points[i]);\\n            coords[2 * i + 1] = getY(points[i]);\\n        }\\n\\n        sortKD(ids, coords, nodeSize, 0, ids.length - 1, 0);\\n    }\\n\\n    range(minX, minY, maxX, maxY) {\\n        return range(this.ids, this.coords, minX, minY, maxX, maxY, this.nodeSize);\\n    }\\n\\n    within(x, y, r) {\\n        return within(this.ids, this.coords, x, y, r, this.nodeSize);\\n    }\\n}\\n\\n// CONCATENATED MODULE: ./node_modules/supercluster/index.js\\n\\n\\n\\nconst defaultOptions = {\\n    minZoom: 0,   // min zoom to generate clusters on\\n    maxZoom: 16,  // max zoom level to cluster the points on\\n    radius: 40,   // cluster radius in pixels\\n    extent: 512,  // tile extent (radius is calculated relative to it)\\n    nodeSize: 64, // size of the KD-tree leaf node, affects performance\\n    log: false,   // whether to log timing info\\n\\n    // a reduce function for calculating custom cluster properties\\n    reduce: null, // (accumulated, props) => { accumulated.sum += props.sum; }\\n\\n    // properties to use for individual points when running the reducer\\n    map: props => props // props => ({sum: props.my_value})\\n};\\n\\nclass supercluster_Supercluster {\\n    constructor(options) {\\n        this.options = extend(Object.create(defaultOptions), options);\\n        this.trees = new Array(this.options.maxZoom + 1);\\n    }\\n\\n    load(points) {\\n        const {log, minZoom, maxZoom, nodeSize} = this.options;\\n\\n        if (log) console.time('total time');\\n\\n        const timerId = `prepare ${  points.length  } points`;\\n        if (log) console.time(timerId);\\n\\n        this.points = points;\\n\\n        // generate a cluster object for each point and index input points into a KD-tree\\n        let clusters = [];\\n        for (let i = 0; i < points.length; i++) {\\n            if (!points[i].geometry) continue;\\n            clusters.push(createPointCluster(points[i], i));\\n        }\\n        this.trees[maxZoom + 1] = new src_KDBush(clusters, supercluster_getX, supercluster_getY, nodeSize, Float32Array);\\n\\n        if (log) console.timeEnd(timerId);\\n\\n        // cluster points on max zoom, then cluster the results on previous zoom, etc.;\\n        // results in a cluster hierarchy across zoom levels\\n        for (let z = maxZoom; z >= minZoom; z--) {\\n            const now = +Date.now();\\n\\n            // create a new set of clusters for the zoom and index them with a KD-tree\\n            clusters = this._cluster(clusters, z);\\n            this.trees[z] = new src_KDBush(clusters, supercluster_getX, supercluster_getY, nodeSize, Float32Array);\\n\\n            if (log) console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);\\n        }\\n\\n        if (log) console.timeEnd('total time');\\n\\n        return this;\\n    }\\n\\n    getClusters(bbox, zoom) {\\n        let minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\\n        const minLat = Math.max(-90, Math.min(90, bbox[1]));\\n        let maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\\n        const maxLat = Math.max(-90, Math.min(90, bbox[3]));\\n\\n        if (bbox[2] - bbox[0] >= 360) {\\n            minLng = -180;\\n            maxLng = 180;\\n        } else if (minLng > maxLng) {\\n            const easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\\n            const westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\\n            return easternHem.concat(westernHem);\\n        }\\n\\n        const tree = this.trees[this._limitZoom(zoom)];\\n        const ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\\n        const clusters = [];\\n        for (const id of ids) {\\n            const c = tree.points[id];\\n            clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\\n        }\\n        return clusters;\\n    }\\n\\n    getChildren(clusterId) {\\n        const originId = clusterId >> 5;\\n        const originZoom = clusterId % 32;\\n        const errorMsg = 'No cluster with the specified id.';\\n\\n        const index = this.trees[originZoom];\\n        if (!index) throw new Error(errorMsg);\\n\\n        const origin = index.points[originId];\\n        if (!origin) throw new Error(errorMsg);\\n\\n        const r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\\n        const ids = index.within(origin.x, origin.y, r);\\n        const children = [];\\n        for (const id of ids) {\\n            const c = index.points[id];\\n            if (c.parentId === clusterId) {\\n                children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\\n            }\\n        }\\n\\n        if (children.length === 0) throw new Error(errorMsg);\\n\\n        return children;\\n    }\\n\\n    getLeaves(clusterId, limit, offset) {\\n        limit = limit || 10;\\n        offset = offset || 0;\\n\\n        const leaves = [];\\n        this._appendLeaves(leaves, clusterId, limit, offset, 0);\\n\\n        return leaves;\\n    }\\n\\n    getTile(z, x, y) {\\n        const tree = this.trees[this._limitZoom(z)];\\n        const z2 = Math.pow(2, z);\\n        const {extent, radius} = this.options;\\n        const p = radius / extent;\\n        const top = (y - p) / z2;\\n        const bottom = (y + 1 + p) / z2;\\n\\n        const tile = {\\n            features: []\\n        };\\n\\n        this._addTileFeatures(\\n            tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom),\\n            tree.points, x, y, z2, tile);\\n\\n        if (x === 0) {\\n            this._addTileFeatures(\\n                tree.range(1 - p / z2, top, 1, bottom),\\n                tree.points, z2, y, z2, tile);\\n        }\\n        if (x === z2 - 1) {\\n            this._addTileFeatures(\\n                tree.range(0, top, p / z2, bottom),\\n                tree.points, -1, y, z2, tile);\\n        }\\n\\n        return tile.features.length ? tile : null;\\n    }\\n\\n    getClusterExpansionZoom(clusterId) {\\n        let clusterZoom = (clusterId % 32) - 1;\\n        while (clusterZoom <= this.options.maxZoom) {\\n            const children = this.getChildren(clusterId);\\n            clusterZoom++;\\n            if (children.length !== 1) break;\\n            clusterId = children[0].properties.cluster_id;\\n        }\\n        return clusterZoom;\\n    }\\n\\n    _appendLeaves(result, clusterId, limit, offset, skipped) {\\n        const children = this.getChildren(clusterId);\\n\\n        for (const child of children) {\\n            const props = child.properties;\\n\\n            if (props && props.cluster) {\\n                if (skipped + props.point_count <= offset) {\\n                    // skip the whole cluster\\n                    skipped += props.point_count;\\n                } else {\\n                    // enter the cluster\\n                    skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);\\n                    // exit the cluster\\n                }\\n            } else if (skipped < offset) {\\n                // skip a single point\\n                skipped++;\\n            } else {\\n                // add a single point\\n                result.push(child);\\n            }\\n            if (result.length === limit) break;\\n        }\\n\\n        return skipped;\\n    }\\n\\n    _addTileFeatures(ids, points, x, y, z2, tile) {\\n        for (const i of ids) {\\n            const c = points[i];\\n            const f = {\\n                type: 1,\\n                geometry: [[\\n                    Math.round(this.options.extent * (c.x * z2 - x)),\\n                    Math.round(this.options.extent * (c.y * z2 - y))\\n                ]],\\n                tags: c.numPoints ? getClusterProperties(c) : this.points[c.index].properties\\n            };\\n            const id = c.numPoints ? c.id : this.points[c.index].id;\\n            if (id !== undefined) {\\n                f.id = id;\\n            }\\n            tile.features.push(f);\\n        }\\n    }\\n\\n    _limitZoom(z) {\\n        return Math.max(this.options.minZoom, Math.min(z, this.options.maxZoom + 1));\\n    }\\n\\n    _cluster(points, zoom) {\\n        const clusters = [];\\n        const {radius, extent, reduce} = this.options;\\n        const r = radius / (extent * Math.pow(2, zoom));\\n\\n        // loop through each point\\n        for (let i = 0; i < points.length; i++) {\\n            const p = points[i];\\n            // if we've already visited the point at this zoom level, skip it\\n            if (p.zoom <= zoom) continue;\\n            p.zoom = zoom;\\n\\n            // find all nearby points\\n            const tree = this.trees[zoom + 1];\\n            const neighborIds = tree.within(p.x, p.y, r);\\n\\n            let numPoints = p.numPoints || 1;\\n            let wx = p.x * numPoints;\\n            let wy = p.y * numPoints;\\n\\n            const clusterProperties = reduce ? this._map(p, true) : null;\\n\\n            // encode both zoom and point index on which the cluster originated\\n            const id = (i << 5) + (zoom + 1);\\n\\n            for (const neighborId of neighborIds) {\\n                const b = tree.points[neighborId];\\n                // filter out neighbors that are already processed\\n                if (b.zoom <= zoom) continue;\\n                b.zoom = zoom; // save the zoom (so it doesn't get processed twice)\\n\\n                const numPoints2 = b.numPoints || 1;\\n                wx += b.x * numPoints2; // accumulate coordinates for calculating weighted center\\n                wy += b.y * numPoints2;\\n\\n                numPoints += numPoints2;\\n                b.parentId = id;\\n\\n                if (reduce) {\\n                    reduce(clusterProperties, this._map(b));\\n                }\\n            }\\n\\n            if (numPoints === 1) {\\n                clusters.push(p);\\n            } else {\\n                p.parentId = id;\\n                clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));\\n            }\\n        }\\n\\n        return clusters;\\n    }\\n\\n    _map(point, clone) {\\n        if (point.numPoints) {\\n            return clone ? extend({}, point.properties) : point.properties;\\n        }\\n        const original = this.points[point.index].properties;\\n        const result = this.options.map(original);\\n        return clone && result === original ? extend({}, result) : result;\\n    }\\n}\\n\\nfunction createCluster(x, y, id, numPoints, properties) {\\n    return {\\n        x, // weighted cluster center\\n        y,\\n        zoom: Infinity, // the last zoom the cluster was processed at\\n        id, // encodes index of the first child of the cluster and its zoom level\\n        parentId: -1, // parent cluster id\\n        numPoints,\\n        properties\\n    };\\n}\\n\\nfunction createPointCluster(p, id) {\\n    const [x, y] = p.geometry.coordinates;\\n    return {\\n        x: lngX(x), // projected point coordinates\\n        y: latY(y),\\n        zoom: Infinity, // the last zoom the point was processed at\\n        index: id, // index of the source feature in the original input array,\\n        parentId: -1 // parent cluster id\\n    };\\n}\\n\\nfunction getClusterJSON(cluster) {\\n    return {\\n        type: 'Feature',\\n        id: cluster.id,\\n        properties: getClusterProperties(cluster),\\n        geometry: {\\n            type: 'Point',\\n            coordinates: [xLng(cluster.x), yLat(cluster.y)]\\n        }\\n    };\\n}\\n\\nfunction getClusterProperties(cluster) {\\n    const count = cluster.numPoints;\\n    const abbrev =\\n        count >= 10000 ? `${Math.round(count / 1000)  }k` :\\n        count >= 1000 ? `${Math.round(count / 100) / 10  }k` : count;\\n    return extend(extend({}, cluster.properties), {\\n        cluster: true,\\n        cluster_id: cluster.id,\\n        point_count: count,\\n        point_count_abbreviated: abbrev\\n    });\\n}\\n\\n// longitude/latitude to spherical mercator in [0..1] range\\nfunction lngX(lng) {\\n    return lng / 360 + 0.5;\\n}\\nfunction latY(lat) {\\n    const sin = Math.sin(lat * Math.PI / 180);\\n    const y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\\n    return y < 0 ? 0 : y > 1 ? 1 : y;\\n}\\n\\n// spherical mercator to longitude/latitude\\nfunction xLng(x) {\\n    return (x - 0.5) * 360;\\n}\\nfunction yLat(y) {\\n    const y2 = (180 - y * 360) * Math.PI / 180;\\n    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\\n}\\n\\nfunction extend(dest, src) {\\n    for (const id in src) dest[id] = src[id];\\n    return dest;\\n}\\n\\nfunction supercluster_getX(p) {\\n    return p.x;\\n}\\nfunction supercluster_getY(p) {\\n    return p.y;\\n}\\n\\n// CONCATENATED MODULE: ./src/SuperclusterWorker.js\\n\\n\\nlet cluster = null\\nlet lastLoadedFeatures = null\\nlet childPointsIdsMap = {}\\nlet clusterHashMap = {}\\n\\nself.onmessage = ({data}) => {\\n  if (data.options.log) {\\n    console.group(data.action)\\n    console.time(data.action)\\n    console.log('workerdata', data)\\n  }\\n\\n  switch (data.action) {\\n    case 'loadFeatures':\\n      loadFeatures(data.data, data.options)\\n      break\\n    case 'clusteringData':\\n      clusteringData(data.data, data.options)\\n      break\\n    case 'expansionZoom':\\n      expansionZoom(data.data)\\n      break\\n    case 'pointsInCluster':\\n      pointsInCluster(data.data)\\n      break\\n  }\\n\\n  if (data.options.log) {\\n    console.timeEnd(data.action)\\n    console.groupEnd(data.action)\\n  }\\n}\\n\\nfunction pointsInCluster({clusterId}) {\\n  const features = cluster.getLeaves(clusterId, Infinity)\\n\\n  sendMessage('pointsInCluster', {\\n    features,\\n    clusterId\\n  })\\n}\\n\\nfunction expansionZoom({clusterId, latlng}) {\\n  const zoom = cluster.getClusterExpansionZoom(clusterId)\\n  sendMessage('expansionZoom', {\\n    latlng,\\n    zoom,\\n    clusterId\\n  })\\n}\\n\\n/**\\n * @link https://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/\\n * @param str\\n * @returns {number}\\n */\\nfunction getHashOfString(str) {\\n  let hash = 0\\n  let i\\n  let chr\\n  if (str.length === 0) return hash\\n  for (i = 0; i < str.length; i++) {\\n    chr   = str.charCodeAt(i)\\n    hash  = ((hash << 5) - hash) + chr\\n    hash |= 0 // Convert to 32bit integer\\n  }\\n  return hash\\n}\\n\\nfunction sendMessage (action, data = {}) {\\n  data.action = action\\n  postMessage(data)\\n}\\n\\nfunction clusteringData({keptPointIds = [], bbox, zoom}, {log, bboxIncreasePer, appendChildIdsToCluster, optimizeRedraw}) {\\n  if (!cluster) {\\n    return\\n  }\\n\\n  // зап  юг вост север\\n  const [w, s, e, n] = bbox\\n\\n  let ewLen = (e - w) * bboxIncreasePer\\n  if (ewLen < 0) ewLen = ewLen * -1\\n  let nsLen = (n - s) * bboxIncreasePer\\n  if (nsLen < 0) nsLen = nsLen * -1\\n\\n  const increasedBbox = [\\n    w - ewLen,\\n    s - nsLen,\\n    e + ewLen,\\n    n + nsLen\\n  ]\\n\\n  const features = cluster.getClusters(increasedBbox, zoom)\\n  const hasKeptPoints = keptPointIds.length > 0\\n  const grabChild = appendChildIdsToCluster || optimizeRedraw\\n\\n  const fLen = features.length\\n  const ids = []\\n  for (let i = 0; i < fLen; i++) {\\n    features[i].properties.composite_id = features[i].properties.cluster_id\\n\\n    if (features[i].properties.cluster && grabChild === true) {\\n      childPointsIdsMap[features[i].properties.cluster_id] = childPointsIdsMap[features[i].properties.cluster_id] || getChildPointsIds(features[i].properties.cluster_id)\\n      const childIds = childPointsIdsMap[features[i].properties.cluster_id]\\n\\n      if (appendChildIdsToCluster === true) {\\n        features[i].properties.childIds = childIds\\n      }\\n\\n      if (optimizeRedraw === true) {\\n        clusterHashMap[features[i].properties.composite_id] = features[i].properties.composite_id || getHashOfString(\\n          childIds.sort().join(';')\\n        ).toString()\\n        features[i].properties.composite_id = clusterHashMap[features[i].properties.composite_id]\\n      }\\n\\n      if (hasKeptPoints === true) {\\n        // TODO to for\\n        keptPointIds.forEach(id => {\\n          if (childIds.indexOf(id) > -1) {\\n            features[i].properties.point_count--\\n          }\\n        })\\n      }\\n    }\\n\\n    if (features[i].properties.id) {\\n      ids.push(features[i].properties.id)\\n    }\\n  }\\n\\n  if (grabChild) {\\n    // TODO to for\\n    keptPointIds.forEach(id => {\\n      if (ids.indexOf(id) === -1 && lastLoadedFeatures) {\\n        // find point and return as feature\\n        const len = lastLoadedFeatures.length\\n        for (let i = 0; i < len; i++) {\\n          if (lastLoadedFeatures[i].properties.id === id) {\\n            features.push(lastLoadedFeatures[i])\\n            break\\n          }\\n        }\\n      }\\n    })\\n  }\\n\\n  log && console.log('single markers ids', ids, 'keptPointIds', keptPointIds)\\n\\n  sendMessage('clusteringData', {\\n    features,\\n    zoom,\\n    bbox\\n  })\\n}\\n\\nfunction getChildPointsIds(clusterId) {\\n  if (childPointsIdsMap[clusterId]) {\\n    return childPointsIdsMap[clusterId]\\n  }\\n\\n  const ids = []\\n\\n  const stack = [clusterId]\\n  while (stack.length) {\\n    const id = stack.pop()\\n    const childs = cluster.getChildren(id)\\n\\n    childs.forEach(children => {\\n      if (children.properties.cluster) {\\n        stack.push(children.properties.cluster_id)\\n      } else {\\n        ids.push(children.properties.id)\\n      }\\n    })\\n  }\\n\\n  childPointsIdsMap[clusterId] = ids\\n\\n  return childPointsIdsMap[clusterId]\\n}\\n\\nfunction loadFeatures({features = []}, {supercluster}) {\\n  cluster = new supercluster_Supercluster(supercluster)\\n  cluster.load(features)\\n  lastLoadedFeatures = features\\n  childPointsIdsMap = {}\\n  clusterHashMap = {}\\n  sendMessage('load')\\n}\\n\\n\\n\\n/***/ })\\n/******/ ]);\\n//# sourceMappingURL=4e13ba28892cefcf9d26.worker.js.map\", __webpack_public_path__ + \"4e13ba28892cefcf9d26.worker.js\");\n};","import * as L from 'leaflet'\n// import SuperclusterWorker from 'worker-loader!./SuperclusterWorker'\n// eslint-disable-next-line import/default\nimport SuperclusterWorker from './SuperclusterWorker'\n\nimport './supercluster.scss'\n\nexport const SuperclusterGroup = L.SuperclusterGroup = L.FeatureGroup.extend({\n  options: {\n    clusterIconFunc: null,\n    pointIconFunc: null,\n    optimizeRedraw: true,\n    appendChildIdsToCluster: false,\n    showClustersOnMaxZoom: true,\n    showedSubClusterMultiplier: 2,\n    showMarkersBeforeMaxZoom: 1,\n    bboxIncreasePer: 0,\n    moveToLastKept: false,\n    moveToLastKeptBoundsMultiplier: 0.3,\n    clusterzIndexOffset: 1000,\n    pointzIndexOffset: 8000,\n    maxMarkersInClusterOnOnePoint: 250,\n    animated: false,\n    spiderfyDistanceMultiplier: 0.8,\n    log: false,\n    legsStyle: {\n      weight: 1,\n      color: '#707070'\n    },\n    supercluster: {\n      radius: 60,\n      extent: 180,\n      minZoom: null,\n      maxZoom: null,\n      log: false\n    }\n  },\n  _geoJsonLayer: null,\n  _worker: null,\n  _map: null,\n  _keptPointIds: [],\n  _initWorker () {\n    this._worker = new SuperclusterWorker()\n    this._worker.onmessage = (d) => this._onWorkerMessage(d)\n    this._worker.onerror = e => this.fire('error', e)\n  },\n  _createGeoJsonLayer () {\n    this._geoJsonLayer = L.geoJson(null, {\n      pointToLayer: (feature, latlng) => {\n        return L.marker(latlng, {\n          zIndexOffset: feature.properties.cluster ?\n            this.options.clusterzIndexOffset :\n            this.options.pointzIndexOffset,\n          icon: feature.properties.cluster ?\n            this.options.clusterIconFunc(feature, latlng) :\n            this.options.pointIconFunc(feature, latlng)\n        })\n      }\n    })\n\n    this._geoJsonLayer.on('click', this._geoJsonClick, this)\n\n    this._geoJsonLayer.on('layerremove', ({layer}) => {\n      this._checkAndUnKeepPoint(layer)\n    })\n    this._geoJsonLayer.on('popupclose', ({layer}) => {\n      this._checkAndUnKeepPoint(layer)\n    })\n    this._geoJsonLayer.on('popupopen', ({layer}) => {\n      this._checkAndKeepPoint(layer)\n    })\n\n    if (this.options.animated === true) {\n      this._geoJsonLayer.on('layeradd', ({layer}) => {\n        this._addClassToIcon(layer, 'animate-add')\n      })\n    }\n  },\n  _deleteLayerFromGeoJsonLayer (l) {\n    this._recursiveRemoveAllOpenedClusterLayer(l)\n\n    this._geoJsonLayer.removeLayer(l)\n  },\n  _geoJsonClick ({latlng, layer}) {\n    if (layer.feature.properties.cluster) {\n      // on cluster click\n      const isMaxZoom = this._map.getZoom() >= this._map.getMaxZoom()\n      const clusterId = layer.feature.properties.cluster_id\n      const clusterOpened = !!layer._openedClusterLayer\n\n      if (clusterOpened) {\n        this._closeCluster(layer)\n      } else if (isMaxZoom === true) {\n        this._sendMessage('pointsInCluster', {\n          clusterId\n        })\n      } else {\n        this._sendMessage('expansionZoom', {\n          clusterId,\n          latlng\n        })\n      }\n    } else {\n      this._onPointClick(null, layer)\n    }\n  },\n  /**\n   * @param parentLayer - exist if click by marker in subcluster\n   * @param layer - marker layer\n   * @private\n   */\n  _onPointClick (parentLayer, layer) {\n    this.fire('point.click', {parentLayer, layer})\n  },\n  _zoomEnd () {\n    this._clusteringData()\n  },\n  _moveEnd () {\n    this._clusteringData()\n  },\n  _clusteringData () {\n    const bounds = this._map.getBounds()\n    const bbox = [bounds.getWest(), bounds.getSouth(), bounds.getEast(), bounds.getNorth()]\n    const zoom = this._map.getZoom()\n\n    this._sendMessage('clusteringData', {\n      zoom,\n      bbox,\n      keptPointIds: this._keptPointIds\n    })\n  },\n  _sendMessage (action, data = {}) {\n    const message = {\n      action,\n      data,\n      options: {\n        bboxIncreasePer: this.options.bboxIncreasePer,\n        optimizeRedraw: this.options.optimizeRedraw,\n        supercluster: this.options.supercluster,\n        log: this.options.log\n      }\n    }\n    this._worker.postMessage(message)\n  },\n  loadGeoJsonData (featuresOrFutureCollection) {\n    let features = []\n    if (Array.isArray(featuresOrFutureCollection)) {\n      features = featuresOrFutureCollection\n    } else {\n      features = featuresOrFutureCollection.features\n    }\n    this._sendMessage('loadFeatures', {features})\n  },\n  _checkAndKeepPoint (layer) {\n    if (layer instanceof L.Marker && !layer.feature.properties.subCluster) {\n      this.keepPoint(layer.feature.properties.id)\n    }\n  },\n  _checkAndUnKeepPoint (layer) {\n    if (layer instanceof L.Marker && !layer.feature.properties.subCluster) {\n      this.unKeepPoint(layer.feature.properties.id)\n    }\n  },\n  keepPoint (id) {\n    if (this._keptPointIds.indexOf(id) > -1) {\n      return\n    }\n    this.options.log && console.log('keepPoint', id)\n    this._keptPointIds.push(id)\n\n    if (!this.options.optimizeRedraw) {\n      console.warn('keepPoint worked only if optimizeRedraw=true')\n    }\n  },\n  unKeepPoint (id) {\n    if (this._keptPointIds.length > 0) {\n      this.options.log && console.log('unKeepPoint', id)\n      this._keptPointIds = this._keptPointIds.filter(v => v !== id)\n      // if we click on point is kept\n      // if we minimize zoom, kep point remove from cluster\n      // we need recalc cluster for get correct cluster size\n      this._clusteringData()\n    }\n  },\n  moveToLastKept () {\n    this.options.log && console.log('move to last')\n    const layers = this._geoJsonLayer.getLayers()\n\n    const lastId = this._keptPointIds[this._keptPointIds.length - 1]\n    if (!lastId) {\n      return\n    }\n\n    const layer = layers.find(l => l.feature.properties.id === lastId)\n    if (!layer) {\n      return\n    }\n\n    const {distMin} = this._getDistanceFromMapCenter()\n    const bounds = L.latLngBounds(layer.getLatLng().toBounds(distMin * this.options.moveToLastKeptBoundsMultiplier))\n    const lastInView = this._map.getBounds().contains(bounds)\n\n    if (!lastInView) {\n      this._map.setView(bounds.getCenter())\n    }\n  },\n  _onWorkerMessage ({data}) {\n    if (this.options.log) {\n      console.group(data.action)\n      console.time(data.action)\n      console.log('workerdata', data)\n    }\n\n    switch (data.action) {\n      case 'clusteringData':\n        this._drawItems(data.features, data.zoom)\n        break\n      case 'load':\n        this._clusteringData(data)\n        break\n      case 'expansionZoom':\n        this._expansionZoom(data)\n        break\n      case 'pointsInCluster':\n        this._openCluster(data)\n        break\n    }\n\n    if (this.options.log) {\n      console.timeEnd(data.action)\n      console.groupEnd(data.action)\n    }\n  },\n  _expansionZoom ({latlng, zoom}) {\n    this._map.setView(latlng, zoom)\n  },\n  _drawItems (features, zoom) {\n    const currentZoom = this._map.getZoom()\n    if (currentZoom !== zoom) {\n      // skip redraw data if user fast change zoom\n      return\n    }\n\n    const layers = this._geoJsonLayer.getLayers()\n    const len = layers.length\n\n    if (this.options.optimizeRedraw === false || len === 0) {\n      // for remove all clusters and subclusters\n      layers.forEach(l => {\n        this._deleteLayerFromGeoJsonLayer(l)\n      })\n      this._geoJsonLayer.addData(features)\n    } else {\n      const addMarkerFeaturesMap = {}\n      const addClustersFeaturesMap = {}\n\n      // create new features map\n      const gLen = features.length\n      for (let i = 0; i < gLen; i++) {\n        if (features[i].properties.cluster) {\n          addClustersFeaturesMap[features[i].properties.composite_id] = features[i]\n        } else {\n          addMarkerFeaturesMap[features[i].properties.id] = features[i]\n        }\n      }\n\n      // remove or update\n      const lLen = layers.length\n      for (let i = 0; i < lLen; i++) {\n        const l = layers[i]\n\n        if (l.feature.properties.cluster) {\n          this._removeOrUpdateLayer(\n            l,\n            addClustersFeaturesMap,\n            'composite_id'\n          )\n        } else {\n          this._removeOrUpdateLayer(\n            l,\n            addMarkerFeaturesMap,\n            'id'\n          )\n        }\n      }\n\n      // add clusters\n      this._geoJsonLayer.addData(Object.values(addClustersFeaturesMap))\n\n      // add markers to map\n      this._geoJsonLayer.addData(Object.values(addMarkerFeaturesMap))\n    }\n\n    this.options.moveToLastKept && this.moveToLastKept()\n\n    this.fire('draw', {layer: this._geoJsonLayer})\n  },\n  _removeOrUpdateLayer (l, featureIdMap, propKey) {\n    const id = l.feature.properties[propKey]\n    if (featureIdMap[id]) {\n      // update marker pos\n      l.setLatLng(\n        new L.LatLng(featureIdMap[id].geometry.coordinates[1], featureIdMap[id].geometry.coordinates[0])\n      )\n\n      if (l.feature.properties.cluster && l.feature.properties.point_count !== featureIdMap[id].properties.point_count) {\n        // update feature info\n        l.feature = featureIdMap[id]\n\n        // update icon with count\n        l.setIcon(this.options.clusterIconFunc(l.feature))\n      } else {\n        // update feature info\n        l.feature = featureIdMap[id]\n      }\n\n      // remove marker from featureMap\n      delete featureIdMap[id]\n\n      this.fire('layer.updated', {layer: l})\n\n      this.options.animated && this._addClassToIcon(l, 'animate-move')\n\n      this._updateMarkersInOpenedClusterLayer(l)\n    } else {\n      // layer not exist in featureMap\n      this._deleteLayerFromGeoJsonLayer(l)\n    }\n  },\n  _clusterIconFunc (feature) {\n    return new L.DivIcon({\n      className: 'supercluster',\n      html: `<div class=\"cluster-icon\">${feature.properties.point_count}</div>`,\n      iconSize: [44, 44],\n      iconAnchor: [22, 22]\n    })\n  },\n  _pointIconFunc () {\n    return new L.DivIcon({\n      className: 'supercluster',\n      html: '<div class=\"point-icon\"><div class=\"pulsate\"></div></div>',\n      iconSize: [14, 14],\n      iconAnchor: [7, 7]\n    })\n  },\n  /**\n   * @override\n   */\n  initialize (options = {}) {\n    for (const opt in options) {\n      if (this.options.hasOwnProperty(opt)) {\n        if (this.options[opt] instanceof Object) {\n          this.options[opt] = Object.assign(this.options[opt], options[opt])\n        } else {\n          this.options[opt] = options[opt]\n        }\n      }\n    }\n\n    this.options.clusterIconFunc = this.options.clusterIconFunc || this._clusterIconFunc\n    this.options.pointIconFunc = this.options.pointIconFunc || this._pointIconFunc\n\n    this._initWorker()\n  },\n  /**\n   * @override\n   */\n  onAdd (map) {\n    this._map = map\n\n    if (!this.options.supercluster.maxZoom) {\n      this.options.supercluster.maxZoom = this._map.getMaxZoom()\n\n      if (!this.options.showClustersOnMaxZoom) {\n        this.options.supercluster.maxZoom = this._map.getMaxZoom() - this.options.showMarkersBeforeMaxZoom\n      }\n    }\n\n    if (!this.options.supercluster.minZoom) {\n      this.options.supercluster.minZoom = this._map.getMinZoom()\n    }\n\n    this._createGeoJsonLayer()\n    this._geoJsonLayer.addTo(this._map)\n\n    this._map.on('zoomend', this._zoomEnd, this)\n    this._map.on('moveend', this._moveEnd, this)\n\n    this._clusteringData()\n  },\n  /**\n   * @override\n   */\n  onRemove (map) {\n    map.off('zoomend', this._zoomEnd, this)\n    map.off('moveend', this._moveEnd, this)\n\n    this._geoJsonLayer.clearLayers()\n  },\n  _updateMarkersInOpenedClusterLayer (layer) {\n    if (!layer._openedClusterLayer) {\n      return\n    }\n\n    // refresh all markers\n    const clusterId = layer.feature.properties.cluster_id\n    this._sendMessage('pointsInCluster', {\n      clusterId\n    })\n  },\n  _closeCluster (layer) {\n    this._recursiveRemoveAllOpenedClusterLayer(layer)\n\n    this._removeClassFromIcon(layer, 'opened')\n  },\n  _updateMarkersInCluster (parentLayer, features, legs) {\n    // create map from exist features\n    const featureIdMap = {}\n\n    const len = features.length\n    for (let i = 0; i < len; i++) {\n      featureIdMap[features[i].properties.id] = features[i]\n    }\n\n    // update or remove marker positions\n    const subLayers = parentLayer._openedClusterLayer.getLayers()\n    const subLen = subLayers.length\n    for (let i = 0; i < subLen; i++) {\n      const l = subLayers[i]\n      const id = l.feature.properties.id\n\n      if (featureIdMap[id]) {\n        l.setLatLng(\n          new L.LatLng(featureIdMap[id].geometry.coordinates[1], featureIdMap[id].geometry.coordinates[0])\n        )\n        l.feature = featureIdMap[id]\n        this.fire('layer.updated', {layer: l})\n\n        // try to update data in subcluster\n        if (l._openedClusterLayer && l.feature.properties.features) {\n          // create spiral or subcluster in subcluster\n          const {segmentalFeatures, legs} = this._segmentFeaturesForLayer(l, l.feature.properties.features)\n\n          this._updateMarkersInCluster(l, segmentalFeatures, legs)\n        } else {\n          // if in new markers not segments - remove\n          this._recursiveRemoveAllOpenedClusterLayer(l)\n\n          // mark as closed\n          this._removeClassFromIcon(l, 'opened')\n        }\n\n        // if marker updated - remove from map\n        delete featureIdMap[id]\n      } else {\n        this._recursiveRemoveAllOpenedClusterLayer(l)\n        parentLayer._openedClusterLayer.removeLayer(l)\n      }\n    }\n\n    // insert markers which not exist in subLayers\n    const featuresForCreate = Object.values(featureIdMap)\n\n    parentLayer._openedClusterLayer.addData([\n      ...featuresForCreate, ...legs\n    ])\n  },\n  _createMarkersInCluster (parentLayer, features, legs) {\n    parentLayer._openedClusterLayer = L.geoJson([\n      ...features, ...legs\n    ], {\n      pointToLayer: (feature, latlng) => {\n        if (feature.properties.subCluster) {\n          return L.marker(latlng, {\n            zIndexOffset: this.options.clusterzIndexOffset,\n            icon: this.options.clusterIconFunc(feature, latlng)\n          })\n        }\n        return L.marker(latlng, {\n          zIndexOffset: this.options.pointzIndexOffset,\n          icon: this.options.pointIconFunc(feature, latlng)\n        })\n      },\n      // we draw line from cluster center to point set style for that\n      style: this.options.legsStyle\n    }).addTo(this._map)\n\n    parentLayer._openedClusterLayer.on('click', ({layer}) => {\n      // detect is a point\n      if (layer instanceof L.Marker) {\n        if (layer.feature.properties.subCluster) {\n          this._toggleSubCluster(layer)\n        } else {\n          this._onPointClick(parentLayer, layer)\n        }\n      }\n      // else it could be path to points\n    })\n  },\n  _recursiveRemoveAllOpenedClusterLayer (l) {\n    if (l._openedClusterLayer)  {\n      const layers = l._openedClusterLayer.getLayers()\n      layers.forEach(subL => {\n        this._recursiveRemoveAllOpenedClusterLayer(subL)\n        l._openedClusterLayer.removeLayer(subL)\n      })\n\n      this._map.removeLayer(l._openedClusterLayer)\n      l._openedClusterLayer = null\n    }\n  },\n  _toggleSubCluster (layer) {\n    if (layer._openedClusterLayer) {\n      this._closeSubCluster(layer)\n    } else {\n      this._openSubCluster(layer, layer.feature.properties.features)\n    }\n  },\n  _openCluster ({clusterId, features}) {\n    const layers = this._geoJsonLayer.getLayers()\n\n    const parentLayer = layers.find(l => l.feature.properties.cluster_id === clusterId)\n    if (!parentLayer) {\n      return\n    }\n\n    const {segmentalFeatures, legs} = this._segmentFeaturesForLayer(parentLayer, features)\n\n    if (parentLayer._openedClusterLayer) {\n      this._updateMarkersInCluster(parentLayer, segmentalFeatures, legs)\n    } else {\n      this._createMarkersInCluster(parentLayer, segmentalFeatures, legs)\n    }\n\n    this._addClassToIcon(parentLayer, 'opened')\n  },\n  _closeSubCluster (parentLayer) {\n    if (!parentLayer._openedClusterLayer) {\n      return\n    }\n\n    this._map.removeLayer(parentLayer._openedClusterLayer)\n    parentLayer._openedClusterLayer = null\n\n    this._removeClassFromIcon(parentLayer, 'opened')\n  },\n  _openSubCluster (parentLayer, features) {\n    const {segmentalFeatures, legs} = this._segmentFeaturesForLayer(parentLayer, features)\n\n    if (parentLayer._openedClusterLayer) {\n      this._updateMarkersInCluster(parentLayer, segmentalFeatures, legs)\n    } else {\n      this._createMarkersInCluster(parentLayer, segmentalFeatures, legs)\n    }\n\n    this._addClassToIcon(parentLayer, 'opened')\n  },\n  _getDistanceFromMapCenter () {\n    const center = this._map.getCenter()\n    const bounds =  this._map.getBounds()\n\n    const centerEast = L.latLng(center.lat, bounds.getEast())\n    const distCenterToEast = center.distanceTo(centerEast)\n\n    const centerNorth = L.latLng(bounds.getNorth(), center.lng)\n    const distCenterToNorth = center.distanceTo(centerNorth)\n\n    const distMin = distCenterToEast > distCenterToNorth ? distCenterToNorth : distCenterToEast\n\n    this.options.log && console.log({distCenterToEast, distCenterToNorth, distMin})\n\n    return {distCenterToEast, distCenterToNorth, distMin}\n  },\n  _segmentFeaturesForLayer (parentLayer, features) {\n    const parentCenter = parentLayer.getLatLng()\n\n    const segmentalFeatures = this._segmentFeatures(features, parentCenter)\n\n    const legs = this._getLegsForMarkersInCluster(parentCenter, segmentalFeatures)\n\n    return {segmentalFeatures, legs}\n  },\n  _segmentFeatures (features, parentCenter) {\n    // we need to align data by id sor saving order\n    // and prevent popup rotate\n    features.sort((a, b) => {\n      if (a.properties.id > b.properties.id) {\n        return 1\n      }\n      if (a.properties.id < b.properties.id) {\n        return -1\n      }\n      return 0\n    })\n\n    const len = features.length\n    const maxMarkersInClusterOnOnePoint = this.options.maxMarkersInClusterOnOnePoint\n    const subClusterCount = Math.ceil(len / maxMarkersInClusterOnOnePoint)\n\n    if (len <= maxMarkersInClusterOnOnePoint) {\n      return this._createSpiral(features, parentCenter)\n    }\n\n    // build points for subcluster\n    const subClusters = []\n    for (let i = 0; i < subClusterCount; i++) {\n      const featuresInSubCluster = features.slice(i * maxMarkersInClusterOnOnePoint, (i + 1) * maxMarkersInClusterOnOnePoint)\n      subClusters.push({\n        type: 'Feature',\n        properties: {\n          id: `sub_${i}`,\n          subCluster: true,\n          point_count: featuresInSubCluster.length,\n          features: featuresInSubCluster\n        },\n        geometry: {\n          type:'Point',\n          coordinates: []\n        }\n      })\n    }\n\n    return this._createSpiral(subClusters, parentCenter, true)\n  },\n  _createSpiral (features, parentCenter, isSubCluster = false) {\n    const spiralLengthFactor = 5\n    const spiderfyDistanceMultiplier = this.options.spiderfyDistanceMultiplier * (isSubCluster ? this.options.showedSubClusterMultiplier : 1)\n    const spiralFootSeparation = 28\n    const spiralLengthStart = 11\n\n    const centerPt = this._map.latLngToLayerPoint(parentCenter)\n\n    const pi2 = Math.PI * 2\n    const count = features.length\n    const separation = spiderfyDistanceMultiplier * spiralFootSeparation\n    const lengthFactor = spiderfyDistanceMultiplier * spiralLengthFactor * pi2\n    let legLength = spiderfyDistanceMultiplier * spiralLengthStart\n    let angle = 0\n    let i\n    let p\n    let coords\n\n    const newFeatures = []\n\n    // Higher index, closer position to cluster center.\n    for (i = count; i >= 0; i--) {\n      // Skip the first position, so that we are already farther from center and we avoid\n      // being under the default cluster icon (especially important for Circle Markers).\n      if (i < count) {\n        p = new L.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle))._round()\n        coords = this._map.layerPointToLatLng(p)\n        features[i].geometry.coordinates = [\n          coords.lng,\n          coords.lat,\n        ]\n        newFeatures.push(features[i])\n      }\n      angle += separation / legLength + i * 0.0005\n      legLength += lengthFactor / angle\n    }\n    return newFeatures\n  },\n  _getLegsForMarkersInCluster (parentCenter, features) {\n    const parentCenterGeometry = [parentCenter.lng, parentCenter.lat]\n\n    const legs = []\n    const len = features.length\n    for (let i = 0; i < len; i++) {\n      legs.push({\n        type: 'LineString',\n        coordinates: [\n          features[i].geometry.coordinates, parentCenterGeometry\n        ]\n      })\n    }\n\n    return legs\n  },\n  _addClassToIcon (l, name) {\n    if (l._icon && l._icon.classList) {\n      l._icon.classList.add(name)\n    }\n  },\n  _removeClassFromIcon (l, name) {\n    if (l._icon && l._icon.classList) {\n      l._icon.classList.remove(name)\n    }\n  }\n})\n\n","'use strict';\n\n// http://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string\n\nvar URL = window.URL || window.webkitURL;\n\nmodule.exports = function (content, url) {\n  try {\n    try {\n      var blob;\n\n      try {\n        // BlobBuilder = Deprecated, but widely implemented\n        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n\n        blob = new BlobBuilder();\n\n        blob.append(content);\n\n        blob = blob.getBlob();\n      } catch (e) {\n        // The proposed API\n        blob = new Blob([content]);\n      }\n\n      return new Worker(URL.createObjectURL(blob));\n    } catch (e) {\n      return new Worker('data:application/javascript,' + encodeURIComponent(content));\n    }\n  } catch (e) {\n    if (!url) {\n      throw Error('Inline worker is not supported');\n    }\n\n    return new Worker(url);\n  }\n};","// extracted by mini-css-extract-plugin"],"sourceRoot":""}
{"version":3,"sources":["webpack://amd/webpack/bootstrap","webpack://amd/external \"L\"","webpack://amd/./src/SuperclusterWorker.js","webpack://amd/./node_modules/worker-loader/dist/workers/InlineWorker.js","webpack://amd/./src/supercluster.scss?cb2e","webpack://amd/./src/WorkerMessageManager.js","webpack://amd/./src/SuperclusterGroup.js"],"names":["module","exports","require","__webpack_public_path__","WorkerMessageManager","onEnd","onWait","_toSend","_onEnd","_onWait","message","cb","action","data","clusterId","push","length","shift","lastCb","pop","isEmpty","SuperclusterGroup","L","extend","options","clusterIconFunc","pointIconFunc","optimizeRedraw","appendChildIdsToCluster","showClustersOnMaxZoom","showedSubClusterMultiplier","showMarkersBeforeMaxZoom","bboxIncreasePer","moveToLastKept","moveToLastKeptBoundsMultiplier","clusterzIndexOffset","pointzIndexOffset","maxMarkersInClusterOnOnePoint","animated","spiderfyDistanceMultiplier","log","legsStyle","weight","color","supercluster","radius","extent","minZoom","maxZoom","_geoJsonLayer","_worker","_map","_keptPointIds","_workerMessageManager","_initWorker","fire","SuperclusterWorker","onmessage","d","_onWorkerMessage","onerror","e","console","group","time","receive","features","_drawItems","zoom","_clusteringData","_expansionZoom","_openCluster","checkQueue","timeEnd","groupEnd","_sendMessage","send","postMessage","_createGeoJsonLayer","pointToLayer","_pointToLayer","bind","on","_geoJsonClick","layer","_checkAndUnKeepPoint","_checkAndKeepPoint","_addClassToIcon","_deleteLayerFromGeoJsonLayer","l","_recursiveRemoveAllOpenedClusterLayer","removeLayer","latlng","feature","properties","cluster","isMaxZoom","getZoom","getMaxZoom","cluster_id","clusterOpened","_openedClusterLayer","_closeCluster","_onPointClick","parentLayer","_zoomEnd","_moveEnd","bounds","getBounds","bbox","getWest","getSouth","getEast","getNorth","keptPointIds","loadGeoJsonData","featuresOrFutureCollection","clean","Array","isArray","subCluster","keepPoint","id","unKeepPoint","indexOf","warn","filter","v","layers","getLayers","lastId","find","_getDistanceFromMapCenter","distMin","getLatLng","toBounds","lastInView","contains","setView","getCenter","currentZoom","len","forEach","addData","addMarkerFeaturesMap","addClustersFeaturesMap","gLen","i","composite_id","lLen","_removeOrUpdateLayer","Object","values","featureIdMap","propKey","setLatLng","geometry","coordinates","point_count","setIcon","_updateMarkersInOpenedClusterLayer","isCluster","zIndexOffset","icon","_clusterIconFunc","className","html","iconSize","iconAnchor","_pointIconFunc","initialize","opt","hasOwnProperty","assign","onAdd","map","getMinZoom","addTo","onRemove","off","clearLayers","_removeClassFromIcon","_updateMarkersInCluster","legs","subLayers","subLen","_segmentFeaturesForLayer","segmentalFeatures","featuresForCreate","_createMarkersInCluster","style","_toggleSubCluster","subL","_closeSubCluster","_openSubCluster","center","centerEast","lat","distCenterToEast","distanceTo","centerNorth","lng","distCenterToNorth","parentCenter","_segmentFeatures","_getLegsForMarkersInCluster","sort","a","b","subClusterCount","Math","ceil","_createSpiral","subClusters","featuresInSubCluster","slice","type","isSubCluster","spiralLengthFactor","spiralFootSeparation","spiralLengthStart","centerPt","latLngToLayerPoint","pi2","PI","count","separation","lengthFactor","legLength","angle","p","coords","newFeatures","x","cos","y","sin","_round","layerPointToLatLng","parentCenterGeometry","name","_icon","classList","add","remove"],"mappings":"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","file":"leaflet-superclaster.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","module.exports = L;","module.exports = function() {\n  return require(\"!!/home/rinat/WebstormProjects/leaflet-superclaster/node_modules/worker-loader/dist/workers/InlineWorker.js\")(\"/******/ (function(modules) { // webpackBootstrap\\n/******/ \\t// The module cache\\n/******/ \\tvar installedModules = {};\\n/******/\\n/******/ \\t// The require function\\n/******/ \\tfunction __webpack_require__(moduleId) {\\n/******/\\n/******/ \\t\\t// Check if module is in cache\\n/******/ \\t\\tif(installedModules[moduleId]) {\\n/******/ \\t\\t\\treturn installedModules[moduleId].exports;\\n/******/ \\t\\t}\\n/******/ \\t\\t// Create a new module (and put it into the cache)\\n/******/ \\t\\tvar module = installedModules[moduleId] = {\\n/******/ \\t\\t\\ti: moduleId,\\n/******/ \\t\\t\\tl: false,\\n/******/ \\t\\t\\texports: {}\\n/******/ \\t\\t};\\n/******/\\n/******/ \\t\\t// Execute the module function\\n/******/ \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n/******/\\n/******/ \\t\\t// Flag the module as loaded\\n/******/ \\t\\tmodule.l = true;\\n/******/\\n/******/ \\t\\t// Return the exports of the module\\n/******/ \\t\\treturn module.exports;\\n/******/ \\t}\\n/******/\\n/******/\\n/******/ \\t// expose the modules object (__webpack_modules__)\\n/******/ \\t__webpack_require__.m = modules;\\n/******/\\n/******/ \\t// expose the module cache\\n/******/ \\t__webpack_require__.c = installedModules;\\n/******/\\n/******/ \\t// define getter function for harmony exports\\n/******/ \\t__webpack_require__.d = function(exports, name, getter) {\\n/******/ \\t\\tif(!__webpack_require__.o(exports, name)) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\\n/******/ \\t\\t}\\n/******/ \\t};\\n/******/\\n/******/ \\t// define __esModule on exports\\n/******/ \\t__webpack_require__.r = function(exports) {\\n/******/ \\t\\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\\n/******/ \\t\\t}\\n/******/ \\t\\tObject.defineProperty(exports, '__esModule', { value: true });\\n/******/ \\t};\\n/******/\\n/******/ \\t// create a fake namespace object\\n/******/ \\t// mode & 1: value is a module id, require it\\n/******/ \\t// mode & 2: merge all properties of value into the ns\\n/******/ \\t// mode & 4: return value when already ns object\\n/******/ \\t// mode & 8|1: behave like require\\n/******/ \\t__webpack_require__.t = function(value, mode) {\\n/******/ \\t\\tif(mode & 1) value = __webpack_require__(value);\\n/******/ \\t\\tif(mode & 8) return value;\\n/******/ \\t\\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\\n/******/ \\t\\tvar ns = Object.create(null);\\n/******/ \\t\\t__webpack_require__.r(ns);\\n/******/ \\t\\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\\n/******/ \\t\\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\\n/******/ \\t\\treturn ns;\\n/******/ \\t};\\n/******/\\n/******/ \\t// getDefaultExport function for compatibility with non-harmony modules\\n/******/ \\t__webpack_require__.n = function(module) {\\n/******/ \\t\\tvar getter = module && module.__esModule ?\\n/******/ \\t\\t\\tfunction getDefault() { return module['default']; } :\\n/******/ \\t\\t\\tfunction getModuleExports() { return module; };\\n/******/ \\t\\t__webpack_require__.d(getter, 'a', getter);\\n/******/ \\t\\treturn getter;\\n/******/ \\t};\\n/******/\\n/******/ \\t// Object.prototype.hasOwnProperty.call\\n/******/ \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n/******/\\n/******/ \\t// __webpack_public_path__\\n/******/ \\t__webpack_require__.p = \\\"/\\\";\\n/******/\\n/******/\\n/******/ \\t// Load entry module and return exports\\n/******/ \\treturn __webpack_require__(__webpack_require__.s = 0);\\n/******/ })\\n/************************************************************************/\\n/******/ ([\\n/* 0 */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n__webpack_require__.r(__webpack_exports__);\\n\\n// CONCATENATED MODULE: ./node_modules/kdbush/src/sort.js\\n\\nfunction sortKD(ids, coords, nodeSize, left, right, depth) {\\n    if (right - left <= nodeSize) return;\\n\\n    const m = (left + right) >> 1;\\n\\n    sort_select(ids, coords, m, left, right, depth % 2);\\n\\n    sortKD(ids, coords, nodeSize, left, m - 1, depth + 1);\\n    sortKD(ids, coords, nodeSize, m + 1, right, depth + 1);\\n}\\n\\nfunction sort_select(ids, coords, k, left, right, inc) {\\n\\n    while (right > left) {\\n        if (right - left > 600) {\\n            const n = right - left + 1;\\n            const m = k - left + 1;\\n            const z = Math.log(n);\\n            const s = 0.5 * Math.exp(2 * z / 3);\\n            const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\\n            const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\\n            const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\\n            sort_select(ids, coords, k, newLeft, newRight, inc);\\n        }\\n\\n        const t = coords[2 * k + inc];\\n        let i = left;\\n        let j = right;\\n\\n        swapItem(ids, coords, left, k);\\n        if (coords[2 * right + inc] > t) swapItem(ids, coords, left, right);\\n\\n        while (i < j) {\\n            swapItem(ids, coords, i, j);\\n            i++;\\n            j--;\\n            while (coords[2 * i + inc] < t) i++;\\n            while (coords[2 * j + inc] > t) j--;\\n        }\\n\\n        if (coords[2 * left + inc] === t) swapItem(ids, coords, left, j);\\n        else {\\n            j++;\\n            swapItem(ids, coords, j, right);\\n        }\\n\\n        if (j <= k) left = j + 1;\\n        if (k <= j) right = j - 1;\\n    }\\n}\\n\\nfunction swapItem(ids, coords, i, j) {\\n    swap(ids, i, j);\\n    swap(coords, 2 * i, 2 * j);\\n    swap(coords, 2 * i + 1, 2 * j + 1);\\n}\\n\\nfunction swap(arr, i, j) {\\n    const tmp = arr[i];\\n    arr[i] = arr[j];\\n    arr[j] = tmp;\\n}\\n\\n// CONCATENATED MODULE: ./node_modules/kdbush/src/range.js\\n\\nfunction range(ids, coords, minX, minY, maxX, maxY, nodeSize) {\\n    const stack = [0, ids.length - 1, 0];\\n    const result = [];\\n    let x, y;\\n\\n    while (stack.length) {\\n        const axis = stack.pop();\\n        const right = stack.pop();\\n        const left = stack.pop();\\n\\n        if (right - left <= nodeSize) {\\n            for (let i = left; i <= right; i++) {\\n                x = coords[2 * i];\\n                y = coords[2 * i + 1];\\n                if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[i]);\\n            }\\n            continue;\\n        }\\n\\n        const m = Math.floor((left + right) / 2);\\n\\n        x = coords[2 * m];\\n        y = coords[2 * m + 1];\\n\\n        if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[m]);\\n\\n        const nextAxis = (axis + 1) % 2;\\n\\n        if (axis === 0 ? minX <= x : minY <= y) {\\n            stack.push(left);\\n            stack.push(m - 1);\\n            stack.push(nextAxis);\\n        }\\n        if (axis === 0 ? maxX >= x : maxY >= y) {\\n            stack.push(m + 1);\\n            stack.push(right);\\n            stack.push(nextAxis);\\n        }\\n    }\\n\\n    return result;\\n}\\n\\n// CONCATENATED MODULE: ./node_modules/kdbush/src/within.js\\n\\nfunction within(ids, coords, qx, qy, r, nodeSize) {\\n    const stack = [0, ids.length - 1, 0];\\n    const result = [];\\n    const r2 = r * r;\\n\\n    while (stack.length) {\\n        const axis = stack.pop();\\n        const right = stack.pop();\\n        const left = stack.pop();\\n\\n        if (right - left <= nodeSize) {\\n            for (let i = left; i <= right; i++) {\\n                if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) result.push(ids[i]);\\n            }\\n            continue;\\n        }\\n\\n        const m = Math.floor((left + right) / 2);\\n\\n        const x = coords[2 * m];\\n        const y = coords[2 * m + 1];\\n\\n        if (sqDist(x, y, qx, qy) <= r2) result.push(ids[m]);\\n\\n        const nextAxis = (axis + 1) % 2;\\n\\n        if (axis === 0 ? qx - r <= x : qy - r <= y) {\\n            stack.push(left);\\n            stack.push(m - 1);\\n            stack.push(nextAxis);\\n        }\\n        if (axis === 0 ? qx + r >= x : qy + r >= y) {\\n            stack.push(m + 1);\\n            stack.push(right);\\n            stack.push(nextAxis);\\n        }\\n    }\\n\\n    return result;\\n}\\n\\nfunction sqDist(ax, ay, bx, by) {\\n    const dx = ax - bx;\\n    const dy = ay - by;\\n    return dx * dx + dy * dy;\\n}\\n\\n// CONCATENATED MODULE: ./node_modules/kdbush/src/index.js\\n\\n\\n\\n\\n\\nconst defaultGetX = p => p[0];\\nconst defaultGetY = p => p[1];\\n\\nclass src_KDBush {\\n    constructor(points, getX = defaultGetX, getY = defaultGetY, nodeSize = 64, ArrayType = Float64Array) {\\n        this.nodeSize = nodeSize;\\n        this.points = points;\\n\\n        const IndexArrayType = points.length < 65536 ? Uint16Array : Uint32Array;\\n\\n        const ids = this.ids = new IndexArrayType(points.length);\\n        const coords = this.coords = new ArrayType(points.length * 2);\\n\\n        for (let i = 0; i < points.length; i++) {\\n            ids[i] = i;\\n            coords[2 * i] = getX(points[i]);\\n            coords[2 * i + 1] = getY(points[i]);\\n        }\\n\\n        sortKD(ids, coords, nodeSize, 0, ids.length - 1, 0);\\n    }\\n\\n    range(minX, minY, maxX, maxY) {\\n        return range(this.ids, this.coords, minX, minY, maxX, maxY, this.nodeSize);\\n    }\\n\\n    within(x, y, r) {\\n        return within(this.ids, this.coords, x, y, r, this.nodeSize);\\n    }\\n}\\n\\n// CONCATENATED MODULE: ./node_modules/supercluster/index.js\\n\\n\\n\\nconst defaultOptions = {\\n    minZoom: 0,   // min zoom to generate clusters on\\n    maxZoom: 16,  // max zoom level to cluster the points on\\n    radius: 40,   // cluster radius in pixels\\n    extent: 512,  // tile extent (radius is calculated relative to it)\\n    nodeSize: 64, // size of the KD-tree leaf node, affects performance\\n    log: false,   // whether to log timing info\\n\\n    // a reduce function for calculating custom cluster properties\\n    reduce: null, // (accumulated, props) => { accumulated.sum += props.sum; }\\n\\n    // properties to use for individual points when running the reducer\\n    map: props => props // props => ({sum: props.my_value})\\n};\\n\\nclass supercluster_Supercluster {\\n    constructor(options) {\\n        this.options = extend(Object.create(defaultOptions), options);\\n        this.trees = new Array(this.options.maxZoom + 1);\\n    }\\n\\n    load(points) {\\n        const {log, minZoom, maxZoom, nodeSize} = this.options;\\n\\n        if (log) console.time('total time');\\n\\n        const timerId = `prepare ${  points.length  } points`;\\n        if (log) console.time(timerId);\\n\\n        this.points = points;\\n\\n        // generate a cluster object for each point and index input points into a KD-tree\\n        let clusters = [];\\n        for (let i = 0; i < points.length; i++) {\\n            if (!points[i].geometry) continue;\\n            clusters.push(createPointCluster(points[i], i));\\n        }\\n        this.trees[maxZoom + 1] = new src_KDBush(clusters, supercluster_getX, supercluster_getY, nodeSize, Float32Array);\\n\\n        if (log) console.timeEnd(timerId);\\n\\n        // cluster points on max zoom, then cluster the results on previous zoom, etc.;\\n        // results in a cluster hierarchy across zoom levels\\n        for (let z = maxZoom; z >= minZoom; z--) {\\n            const now = +Date.now();\\n\\n            // create a new set of clusters for the zoom and index them with a KD-tree\\n            clusters = this._cluster(clusters, z);\\n            this.trees[z] = new src_KDBush(clusters, supercluster_getX, supercluster_getY, nodeSize, Float32Array);\\n\\n            if (log) console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);\\n        }\\n\\n        if (log) console.timeEnd('total time');\\n\\n        return this;\\n    }\\n\\n    getClusters(bbox, zoom) {\\n        let minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\\n        const minLat = Math.max(-90, Math.min(90, bbox[1]));\\n        let maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\\n        const maxLat = Math.max(-90, Math.min(90, bbox[3]));\\n\\n        if (bbox[2] - bbox[0] >= 360) {\\n            minLng = -180;\\n            maxLng = 180;\\n        } else if (minLng > maxLng) {\\n            const easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\\n            const westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\\n            return easternHem.concat(westernHem);\\n        }\\n\\n        const tree = this.trees[this._limitZoom(zoom)];\\n        const ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\\n        const clusters = [];\\n        for (const id of ids) {\\n            const c = tree.points[id];\\n            clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\\n        }\\n        return clusters;\\n    }\\n\\n    getChildren(clusterId) {\\n        const originId = clusterId >> 5;\\n        const originZoom = clusterId % 32;\\n        const errorMsg = 'No cluster with the specified id.';\\n\\n        const index = this.trees[originZoom];\\n        if (!index) throw new Error(errorMsg);\\n\\n        const origin = index.points[originId];\\n        if (!origin) throw new Error(errorMsg);\\n\\n        const r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\\n        const ids = index.within(origin.x, origin.y, r);\\n        const children = [];\\n        for (const id of ids) {\\n            const c = index.points[id];\\n            if (c.parentId === clusterId) {\\n                children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\\n            }\\n        }\\n\\n        if (children.length === 0) throw new Error(errorMsg);\\n\\n        return children;\\n    }\\n\\n    getLeaves(clusterId, limit, offset) {\\n        limit = limit || 10;\\n        offset = offset || 0;\\n\\n        const leaves = [];\\n        this._appendLeaves(leaves, clusterId, limit, offset, 0);\\n\\n        return leaves;\\n    }\\n\\n    getTile(z, x, y) {\\n        const tree = this.trees[this._limitZoom(z)];\\n        const z2 = Math.pow(2, z);\\n        const {extent, radius} = this.options;\\n        const p = radius / extent;\\n        const top = (y - p) / z2;\\n        const bottom = (y + 1 + p) / z2;\\n\\n        const tile = {\\n            features: []\\n        };\\n\\n        this._addTileFeatures(\\n            tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom),\\n            tree.points, x, y, z2, tile);\\n\\n        if (x === 0) {\\n            this._addTileFeatures(\\n                tree.range(1 - p / z2, top, 1, bottom),\\n                tree.points, z2, y, z2, tile);\\n        }\\n        if (x === z2 - 1) {\\n            this._addTileFeatures(\\n                tree.range(0, top, p / z2, bottom),\\n                tree.points, -1, y, z2, tile);\\n        }\\n\\n        return tile.features.length ? tile : null;\\n    }\\n\\n    getClusterExpansionZoom(clusterId) {\\n        let clusterZoom = (clusterId % 32) - 1;\\n        while (clusterZoom <= this.options.maxZoom) {\\n            const children = this.getChildren(clusterId);\\n            clusterZoom++;\\n            if (children.length !== 1) break;\\n            clusterId = children[0].properties.cluster_id;\\n        }\\n        return clusterZoom;\\n    }\\n\\n    _appendLeaves(result, clusterId, limit, offset, skipped) {\\n        const children = this.getChildren(clusterId);\\n\\n        for (const child of children) {\\n            const props = child.properties;\\n\\n            if (props && props.cluster) {\\n                if (skipped + props.point_count <= offset) {\\n                    // skip the whole cluster\\n                    skipped += props.point_count;\\n                } else {\\n                    // enter the cluster\\n                    skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);\\n                    // exit the cluster\\n                }\\n            } else if (skipped < offset) {\\n                // skip a single point\\n                skipped++;\\n            } else {\\n                // add a single point\\n                result.push(child);\\n            }\\n            if (result.length === limit) break;\\n        }\\n\\n        return skipped;\\n    }\\n\\n    _addTileFeatures(ids, points, x, y, z2, tile) {\\n        for (const i of ids) {\\n            const c = points[i];\\n            const f = {\\n                type: 1,\\n                geometry: [[\\n                    Math.round(this.options.extent * (c.x * z2 - x)),\\n                    Math.round(this.options.extent * (c.y * z2 - y))\\n                ]],\\n                tags: c.numPoints ? getClusterProperties(c) : this.points[c.index].properties\\n            };\\n            const id = c.numPoints ? c.id : this.points[c.index].id;\\n            if (id !== undefined) {\\n                f.id = id;\\n            }\\n            tile.features.push(f);\\n        }\\n    }\\n\\n    _limitZoom(z) {\\n        return Math.max(this.options.minZoom, Math.min(z, this.options.maxZoom + 1));\\n    }\\n\\n    _cluster(points, zoom) {\\n        const clusters = [];\\n        const {radius, extent, reduce} = this.options;\\n        const r = radius / (extent * Math.pow(2, zoom));\\n\\n        // loop through each point\\n        for (let i = 0; i < points.length; i++) {\\n            const p = points[i];\\n            // if we've already visited the point at this zoom level, skip it\\n            if (p.zoom <= zoom) continue;\\n            p.zoom = zoom;\\n\\n            // find all nearby points\\n            const tree = this.trees[zoom + 1];\\n            const neighborIds = tree.within(p.x, p.y, r);\\n\\n            let numPoints = p.numPoints || 1;\\n            let wx = p.x * numPoints;\\n            let wy = p.y * numPoints;\\n\\n            const clusterProperties = reduce ? this._map(p, true) : null;\\n\\n            // encode both zoom and point index on which the cluster originated\\n            const id = (i << 5) + (zoom + 1);\\n\\n            for (const neighborId of neighborIds) {\\n                const b = tree.points[neighborId];\\n                // filter out neighbors that are already processed\\n                if (b.zoom <= zoom) continue;\\n                b.zoom = zoom; // save the zoom (so it doesn't get processed twice)\\n\\n                const numPoints2 = b.numPoints || 1;\\n                wx += b.x * numPoints2; // accumulate coordinates for calculating weighted center\\n                wy += b.y * numPoints2;\\n\\n                numPoints += numPoints2;\\n                b.parentId = id;\\n\\n                if (reduce) {\\n                    reduce(clusterProperties, this._map(b));\\n                }\\n            }\\n\\n            if (numPoints === 1) {\\n                clusters.push(p);\\n            } else {\\n                p.parentId = id;\\n                clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));\\n            }\\n        }\\n\\n        return clusters;\\n    }\\n\\n    _map(point, clone) {\\n        if (point.numPoints) {\\n            return clone ? extend({}, point.properties) : point.properties;\\n        }\\n        const original = this.points[point.index].properties;\\n        const result = this.options.map(original);\\n        return clone && result === original ? extend({}, result) : result;\\n    }\\n}\\n\\nfunction createCluster(x, y, id, numPoints, properties) {\\n    return {\\n        x, // weighted cluster center\\n        y,\\n        zoom: Infinity, // the last zoom the cluster was processed at\\n        id, // encodes index of the first child of the cluster and its zoom level\\n        parentId: -1, // parent cluster id\\n        numPoints,\\n        properties\\n    };\\n}\\n\\nfunction createPointCluster(p, id) {\\n    const [x, y] = p.geometry.coordinates;\\n    return {\\n        x: lngX(x), // projected point coordinates\\n        y: latY(y),\\n        zoom: Infinity, // the last zoom the point was processed at\\n        index: id, // index of the source feature in the original input array,\\n        parentId: -1 // parent cluster id\\n    };\\n}\\n\\nfunction getClusterJSON(cluster) {\\n    return {\\n        type: 'Feature',\\n        id: cluster.id,\\n        properties: getClusterProperties(cluster),\\n        geometry: {\\n            type: 'Point',\\n            coordinates: [xLng(cluster.x), yLat(cluster.y)]\\n        }\\n    };\\n}\\n\\nfunction getClusterProperties(cluster) {\\n    const count = cluster.numPoints;\\n    const abbrev =\\n        count >= 10000 ? `${Math.round(count / 1000)  }k` :\\n        count >= 1000 ? `${Math.round(count / 100) / 10  }k` : count;\\n    return extend(extend({}, cluster.properties), {\\n        cluster: true,\\n        cluster_id: cluster.id,\\n        point_count: count,\\n        point_count_abbreviated: abbrev\\n    });\\n}\\n\\n// longitude/latitude to spherical mercator in [0..1] range\\nfunction lngX(lng) {\\n    return lng / 360 + 0.5;\\n}\\nfunction latY(lat) {\\n    const sin = Math.sin(lat * Math.PI / 180);\\n    const y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\\n    return y < 0 ? 0 : y > 1 ? 1 : y;\\n}\\n\\n// spherical mercator to longitude/latitude\\nfunction xLng(x) {\\n    return (x - 0.5) * 360;\\n}\\nfunction yLat(y) {\\n    const y2 = (180 - y * 360) * Math.PI / 180;\\n    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\\n}\\n\\nfunction extend(dest, src) {\\n    for (const id in src) dest[id] = src[id];\\n    return dest;\\n}\\n\\nfunction supercluster_getX(p) {\\n    return p.x;\\n}\\nfunction supercluster_getY(p) {\\n    return p.y;\\n}\\n\\n// CONCATENATED MODULE: ./src/SuperclusterWorker.js\\n\\n\\nlet cluster = null\\nlet lastLoadedFeatures = null\\nlet childPointsIdsMap = {}\\nlet clusterHashMap = {}\\n\\nself.onmessage = ({data}) => {\\n  if (data.options.log) {\\n    console.group(data.action)\\n    console.time(data.action)\\n    console.log('workerdata', data)\\n  }\\n\\n  switch (data.action) {\\n    case 'loadFeatures':\\n      loadFeatures(data.data, data.options)\\n      break\\n    case 'clusteringData':\\n      clusteringData(data.data, data.options)\\n      break\\n    case 'expansionZoom':\\n      expansionZoom(data.data)\\n      break\\n    case 'pointsInCluster':\\n      pointsInCluster(data.data)\\n      break\\n  }\\n\\n  if (data.options.log) {\\n    console.timeEnd(data.action)\\n    console.groupEnd(data.action)\\n  }\\n}\\n\\nfunction pointsInCluster({clusterId}) {\\n  const features = cluster.getLeaves(clusterId, Infinity)\\n\\n  sendMessage('pointsInCluster', {\\n    features,\\n    clusterId\\n  })\\n}\\n\\nfunction expansionZoom({clusterId, latlng}) {\\n  const zoom = cluster.getClusterExpansionZoom(clusterId)\\n  sendMessage('expansionZoom', {\\n    latlng,\\n    zoom,\\n    clusterId\\n  })\\n}\\n\\n/**\\n * @link https://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/\\n * @param str\\n * @returns {number}\\n */\\nfunction getHashOfString(str) {\\n  let hash = 0\\n  let i\\n  let chr\\n  if (str.length === 0) return hash\\n  for (i = 0; i < str.length; i++) {\\n    chr   = str.charCodeAt(i)\\n    hash  = ((hash << 5) - hash) + chr\\n    hash |= 0 // Convert to 32bit integer\\n  }\\n  return hash\\n}\\n\\nfunction sendMessage (action, data = {}) {\\n  data.action = action\\n  postMessage(data)\\n}\\n\\nfunction clusteringData({keptPointIds = [], bbox, zoom}, {log, bboxIncreasePer, appendChildIdsToCluster, optimizeRedraw}) {\\n  if (!cluster) {\\n    sendMessage('clusteringData', {\\n      features: null\\n    })\\n    return\\n  }\\n\\n  //     \\n  const [w, s, e, n] = bbox\\n\\n  let ewLen = (e - w) * bboxIncreasePer\\n  if (ewLen < 0) ewLen = ewLen * -1\\n  let nsLen = (n - s) * bboxIncreasePer\\n  if (nsLen < 0) nsLen = nsLen * -1\\n\\n  const increasedBbox = [\\n    w - ewLen,\\n    s - nsLen,\\n    e + ewLen,\\n    n + nsLen\\n  ]\\n\\n  const features = cluster.getClusters(increasedBbox, zoom)\\n  const hasKeptPoints = keptPointIds.length > 0\\n  const grabChild = appendChildIdsToCluster || optimizeRedraw\\n\\n  const fLen = features.length\\n  const ids = []\\n  for (let i = 0; i < fLen; i++) {\\n    features[i].properties.composite_id = features[i].properties.cluster_id\\n\\n    if (features[i].properties.cluster && grabChild === true) {\\n      childPointsIdsMap[features[i].properties.cluster_id] = childPointsIdsMap[features[i].properties.cluster_id] || getChildPointsIds(features[i].properties.cluster_id)\\n      const childIds = childPointsIdsMap[features[i].properties.cluster_id]\\n\\n      if (appendChildIdsToCluster === true) {\\n        features[i].properties.childIds = childIds\\n      }\\n\\n      if (optimizeRedraw === true) {\\n        clusterHashMap[features[i].properties.composite_id] = features[i].properties.composite_id || getHashOfString(\\n          childIds.sort().join(';')\\n        ).toString()\\n        features[i].properties.composite_id = clusterHashMap[features[i].properties.composite_id]\\n      }\\n\\n      if (hasKeptPoints === true) {\\n        // TODO to for\\n        keptPointIds.forEach(id => {\\n          if (childIds.indexOf(id) > -1) {\\n            features[i].properties.point_count--\\n          }\\n        })\\n      }\\n    }\\n\\n    if (features[i].properties.id) {\\n      ids.push(features[i].properties.id)\\n    }\\n  }\\n\\n  if (grabChild) {\\n    // TODO to for\\n    keptPointIds.forEach(id => {\\n      if (ids.indexOf(id) === -1 && lastLoadedFeatures) {\\n        // find point and return as feature\\n        const len = lastLoadedFeatures.length\\n        for (let i = 0; i < len; i++) {\\n          if (lastLoadedFeatures[i].properties.id === id) {\\n            features.push(lastLoadedFeatures[i])\\n            break\\n          }\\n        }\\n      }\\n    })\\n  }\\n\\n  log && console.log('single markers ids', ids, 'keptPointIds', keptPointIds)\\n\\n  sendMessage('clusteringData', {\\n    features,\\n    zoom,\\n    bbox\\n  })\\n}\\n\\nfunction getChildPointsIds(clusterId) {\\n  if (childPointsIdsMap[clusterId]) {\\n    return childPointsIdsMap[clusterId]\\n  }\\n\\n  const ids = []\\n\\n  const stack = [clusterId]\\n  while (stack.length) {\\n    const id = stack.pop()\\n    const childs = cluster.getChildren(id)\\n\\n    childs.forEach(children => {\\n      if (children.properties.cluster) {\\n        stack.push(children.properties.cluster_id)\\n      } else {\\n        ids.push(children.properties.id)\\n      }\\n    })\\n  }\\n\\n  childPointsIdsMap[clusterId] = ids\\n\\n  return childPointsIdsMap[clusterId]\\n}\\n\\nfunction loadFeatures({features = []}, {supercluster}) {\\n  cluster = new supercluster_Supercluster(supercluster)\\n  cluster.load(features)\\n  lastLoadedFeatures = features\\n  childPointsIdsMap = {}\\n  clusterHashMap = {}\\n  sendMessage('loadFeatures')\\n}\\n\\n\\n\\n/***/ })\\n/******/ ]);\\n//# sourceMappingURL=540d95081284d1625a96.worker.js.map\", __webpack_public_path__ + \"540d95081284d1625a96.worker.js\");\n};","'use strict';\n\n// http://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string\n\nvar URL = window.URL || window.webkitURL;\n\nmodule.exports = function (content, url) {\n  try {\n    try {\n      var blob;\n\n      try {\n        // BlobBuilder = Deprecated, but widely implemented\n        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n\n        blob = new BlobBuilder();\n\n        blob.append(content);\n\n        blob = blob.getBlob();\n      } catch (e) {\n        // The proposed API\n        blob = new Blob([content]);\n      }\n\n      return new Worker(URL.createObjectURL(blob));\n    } catch (e) {\n      return new Worker('data:application/javascript,' + encodeURIComponent(content));\n    }\n  } catch (e) {\n    if (!url) {\n      throw Error('Inline worker is not supported');\n    }\n\n    return new Worker(url);\n  }\n};","// extracted by mini-css-extract-plugin","export class WorkerMessageManager {\n  constructor ({onEnd = () => '', onWait = () => ''} = {}) {\n    this._toSend = {}\n    this._onEnd = onEnd\n    this._onWait = onWait\n  }\n\n  send (message, cb) {\n    const action = `${message.action}.${message.data.clusterId || ''}`\n\n    if (!this._toSend[action]) {\n      this._toSend[action] = []\n    }\n\n    // cb()\n    this._toSend[action].push(cb)\n\n    if (this._toSend[action].length === 1) {\n      // if only one item - execute\n      cb()\n    }\n  }\n\n  receive (message) {\n    const action = `${message.action}.${message.clusterId || ''}`\n\n    if (!this._toSend[action]) {\n      this._toSend[action] = []\n    }\n\n    // remove executed\n    this._toSend[action].shift()\n\n    if (this._toSend[action].length > 0) {\n      // if we have many items, execute only last\n      // others - drop\n      const lastCb = this._toSend[action].pop()\n      this._toSend[action] = [lastCb]\n      lastCb()\n    }\n  }\n\n  /**\n   * Call cb in no data for send to workers\n   * or data exist\n   */\n  checkQueue() {\n    let isEmpty = true\n    for (const action in this._toSend) {\n      if (this._toSend[action].length > 0) {\n        isEmpty = false\n        break\n      }\n    }\n\n    if (isEmpty === true) {\n      this._onEnd()\n    } else {\n      this._onWait()\n    }\n  }\n\n  clean () {\n    this._toSend = {}\n  }\n}\n","import * as L from 'leaflet'\n// import SuperclusterWorker from 'worker-loader!./SuperclusterWorker'\n// eslint-disable-next-line import/default\nimport SuperclusterWorker from './SuperclusterWorker'\nimport {WorkerMessageManager} from './WorkerMessageManager'\n\nimport './supercluster.scss'\n\nexport const SuperclusterGroup = L.SuperclusterGroup = L.FeatureGroup.extend({\n  options: {\n    clusterIconFunc: null,\n    pointIconFunc: null,\n    optimizeRedraw: true,\n    appendChildIdsToCluster: false,\n    showClustersOnMaxZoom: true,\n    showedSubClusterMultiplier: 2,\n    showMarkersBeforeMaxZoom: 1,\n    bboxIncreasePer: 0,\n    moveToLastKept: false,\n    moveToLastKeptBoundsMultiplier: 0.3,\n    clusterzIndexOffset: 1000,\n    pointzIndexOffset: 8000,\n    maxMarkersInClusterOnOnePoint: 250,\n    animated: false,\n    spiderfyDistanceMultiplier: 0.8,\n    log: false,\n    legsStyle: {\n      weight: 1,\n      color: '#707070'\n    },\n    supercluster: {\n      radius: 60,\n      extent: 180,\n      minZoom: null,\n      maxZoom: null,\n      log: false\n    }\n  },\n  _geoJsonLayer: null,\n  _worker: null,\n  _map: null,\n  _keptPointIds: [],\n  _workerMessageManager: null,\n  _initWorker () {\n    this._workerMessageManager = new WorkerMessageManager({\n      onEnd: () => this.fire('end'),\n      onWait: () => this.fire('wait')\n    })\n    this._worker = new SuperclusterWorker()\n    this._worker.onmessage = (d) => this._onWorkerMessage(d)\n    this._worker.onerror = e => this.fire('error', e)\n  },\n  _onWorkerMessage ({data}) {\n    if (this.options.log) {\n      console.group(data.action)\n      console.time(data.action)\n      console.log('workerdata', data)\n    }\n\n    this._workerMessageManager.receive(data)\n\n    if (!this._map) {\n      return\n    }\n\n    switch (data.action) {\n      case 'clusteringData':\n        if (data.features) {\n          this._drawItems(data.features, data.zoom)\n        }\n        break\n      case 'loadFeatures':\n        this._clusteringData(data)\n        break\n      case 'expansionZoom':\n        this._expansionZoom(data)\n        break\n      case 'pointsInCluster':\n        this._openCluster(data)\n        break\n    }\n\n    this._workerMessageManager.checkQueue()\n\n    if (this.options.log) {\n      console.timeEnd(data.action)\n      console.groupEnd(data.action)\n    }\n  },\n  _sendMessage (action, data = {}) {\n    const message = {\n      action,\n      data,\n      options: {\n        bboxIncreasePer: this.options.bboxIncreasePer,\n        optimizeRedraw: this.options.optimizeRedraw,\n        supercluster: this.options.supercluster,\n        log: this.options.log\n      }\n    }\n    this._workerMessageManager.send(message, () => {\n      this._worker.postMessage(message)\n    })\n    this._workerMessageManager.checkQueue()\n  },\n  _createGeoJsonLayer () {\n    this._geoJsonLayer = L.geoJson(null, {\n      pointToLayer: this._pointToLayer.bind(this)\n    })\n\n    this._geoJsonLayer.on('click', this._geoJsonClick, this)\n\n    this._geoJsonLayer.on('layerremove', ({layer}) => {\n      this._checkAndUnKeepPoint(layer)\n    })\n    this._geoJsonLayer.on('popupclose', ({layer}) => {\n      this._checkAndUnKeepPoint(layer)\n    })\n    this._geoJsonLayer.on('popupopen', ({layer}) => {\n      this._checkAndKeepPoint(layer)\n    })\n\n    if (this.options.animated === true) {\n      this._geoJsonLayer.on('layeradd', ({layer}) => {\n        this._addClassToIcon(layer, 'animate-add')\n      })\n    }\n  },\n  _deleteLayerFromGeoJsonLayer (l) {\n    this._recursiveRemoveAllOpenedClusterLayer(l)\n\n    this._geoJsonLayer.removeLayer(l)\n  },\n  _geoJsonClick ({latlng, layer}) {\n    if (layer.feature.properties.cluster) {\n      // on cluster click\n      const isMaxZoom = this._map.getZoom() >= this._map.getMaxZoom()\n      const clusterId = layer.feature.properties.cluster_id\n      const clusterOpened = !!layer._openedClusterLayer\n\n      if (clusterOpened) {\n        this._closeCluster(layer)\n      } else if (isMaxZoom === true) {\n        this._sendMessage('pointsInCluster', {\n          clusterId\n        })\n      } else {\n        this._sendMessage('expansionZoom', {\n          clusterId,\n          latlng\n        })\n      }\n    } else {\n      this._onPointClick(null, layer)\n    }\n  },\n  /**\n   * @param parentLayer - exist if click by marker in subcluster\n   * @param layer - marker layer\n   * @private\n   */\n  _onPointClick (parentLayer, layer) {\n    this.fire('point.click', {parentLayer, layer})\n  },\n  _zoomEnd () {\n    this._clusteringData()\n  },\n  _moveEnd () {\n    this._clusteringData()\n  },\n  _clusteringData () {\n    const bounds = this._map.getBounds()\n    const bbox = [bounds.getWest(), bounds.getSouth(), bounds.getEast(), bounds.getNorth()]\n    const zoom = this._map.getZoom()\n\n    this._sendMessage('clusteringData', {\n      zoom,\n      bbox,\n      keptPointIds: this._keptPointIds\n    })\n  },\n  loadGeoJsonData (featuresOrFutureCollection) {\n    this._workerMessageManager.clean()\n\n    let features = []\n    if (Array.isArray(featuresOrFutureCollection)) {\n      features = featuresOrFutureCollection\n    } else {\n      features = featuresOrFutureCollection.features\n    }\n\n    this._sendMessage('loadFeatures', {features})\n  },\n  _checkAndKeepPoint (layer) {\n    if (layer instanceof L.Marker && !layer.feature.properties.subCluster) {\n      this.keepPoint(layer.feature.properties.id)\n    }\n  },\n  _checkAndUnKeepPoint (layer) {\n    if (layer instanceof L.Marker && !layer.feature.properties.subCluster) {\n      this.unKeepPoint(layer.feature.properties.id)\n    }\n  },\n  keepPoint (id) {\n    if (this._keptPointIds.indexOf(id) > -1) {\n      return\n    }\n    this.options.log && console.log('keepPoint', id)\n    this._keptPointIds.push(id)\n\n    if (!this.options.optimizeRedraw) {\n      console.warn('keepPoint worked only if optimizeRedraw=true')\n    }\n  },\n  unKeepPoint (id) {\n    if (this._keptPointIds.length > 0) {\n      this.options.log && console.log('unKeepPoint', id)\n      this._keptPointIds = this._keptPointIds.filter(v => v !== id)\n      // if we click on point is kept\n      // if we minimize zoom, kep point remove from cluster\n      // we need recalc cluster for get correct cluster size\n      this._clusteringData()\n    }\n  },\n  moveToLastKept () {\n    this.options.log && console.log('move to last')\n    const layers = this._geoJsonLayer.getLayers()\n\n    const lastId = this._keptPointIds[this._keptPointIds.length - 1]\n    if (!lastId) {\n      return\n    }\n\n    const layer = layers.find(l => l.feature.properties.id === lastId)\n    if (!layer) {\n      return\n    }\n\n    const {distMin} = this._getDistanceFromMapCenter()\n    const bounds = L.latLngBounds(layer.getLatLng().toBounds(distMin * this.options.moveToLastKeptBoundsMultiplier))\n    const lastInView = this._map.getBounds().contains(bounds)\n\n    if (!lastInView) {\n      this._map.setView(bounds.getCenter())\n    }\n  },\n  _expansionZoom ({latlng, zoom}) {\n    this._map.setView(latlng, zoom)\n  },\n  _drawItems (features, zoom) {\n    const currentZoom = this._map.getZoom()\n    if (currentZoom !== zoom) {\n      // skip redraw data if user fast change zoom\n      return\n    }\n\n    const layers = this._geoJsonLayer.getLayers()\n    const len = layers.length\n\n    if (this.options.optimizeRedraw === false || len === 0) {\n      // for remove all clusters and subclusters\n      layers.forEach(l => {\n        this._deleteLayerFromGeoJsonLayer(l)\n      })\n      this._geoJsonLayer.addData(features)\n    } else {\n      const addMarkerFeaturesMap = {}\n      const addClustersFeaturesMap = {}\n\n      // create new features map\n      const gLen = features.length\n      for (let i = 0; i < gLen; i++) {\n        if (features[i].properties.cluster) {\n          addClustersFeaturesMap[features[i].properties.composite_id] = features[i]\n        } else {\n          addMarkerFeaturesMap[features[i].properties.id] = features[i]\n        }\n      }\n\n      // remove or update\n      const lLen = layers.length\n      for (let i = 0; i < lLen; i++) {\n        const l = layers[i]\n\n        if (l.feature.properties.cluster) {\n          this._removeOrUpdateLayer(\n            l,\n            addClustersFeaturesMap,\n            'composite_id'\n          )\n        } else {\n          this._removeOrUpdateLayer(\n            l,\n            addMarkerFeaturesMap,\n            'id'\n          )\n        }\n      }\n\n      // add clusters\n      this._geoJsonLayer.addData(Object.values(addClustersFeaturesMap))\n\n      // add markers to map\n      this._geoJsonLayer.addData(Object.values(addMarkerFeaturesMap))\n    }\n\n    this.options.moveToLastKept && this.moveToLastKept()\n\n    this.fire('draw', {layer: this._geoJsonLayer})\n  },\n  _removeOrUpdateLayer (l, featureIdMap, propKey) {\n    const id = l.feature.properties[propKey]\n    if (featureIdMap[id]) {\n      // update marker pos\n      l.setLatLng(\n        new L.LatLng(featureIdMap[id].geometry.coordinates[1], featureIdMap[id].geometry.coordinates[0])\n      )\n\n      if (l.feature.properties.cluster && l.feature.properties.point_count !== featureIdMap[id].properties.point_count) {\n        // update feature info\n        l.feature = featureIdMap[id]\n\n        // update icon with count\n        l.setIcon(this.options.clusterIconFunc(l.feature))\n      } else {\n        // update feature info\n        l.feature = featureIdMap[id]\n      }\n\n      // remove marker from featureMap\n      delete featureIdMap[id]\n\n      this.fire('layer.updated', {layer: l})\n\n      this.options.animated && this._addClassToIcon(l, 'animate-move')\n\n      this._updateMarkersInOpenedClusterLayer(l)\n    } else {\n      // layer not exist in featureMap\n      this._deleteLayerFromGeoJsonLayer(l)\n    }\n  },\n  _pointToLayer (feature, latlng) {\n    const isCluster = feature.properties.subCluster || feature.properties.cluster\n\n    if (isCluster) {\n      return L.marker(latlng, {\n        zIndexOffset: this.options.clusterzIndexOffset,\n        icon: this.options.clusterIconFunc(feature, latlng)\n      })\n    }\n\n    return L.marker(latlng, {\n      zIndexOffset: this.options.pointzIndexOffset,\n      icon: this.options.pointIconFunc(feature, latlng)\n    })\n  },\n  _clusterIconFunc (feature) {\n    return new L.DivIcon({\n      className: 'supercluster',\n      html: `<div class=\"cluster-icon\">${feature.properties.point_count}</div>`,\n      iconSize: [44, 44],\n      iconAnchor: [22, 22]\n    })\n  },\n  _pointIconFunc () {\n    return new L.DivIcon({\n      className: 'supercluster',\n      html: '<div class=\"point-icon\"><div class=\"pulsate\"></div></div>',\n      iconSize: [14, 14],\n      iconAnchor: [7, 7]\n    })\n  },\n  /**\n   * @override\n   */\n  initialize (options = {}) {\n    for (const opt in options) {\n      if (this.options.hasOwnProperty(opt)) {\n        if (this.options[opt] instanceof Object) {\n          this.options[opt] = Object.assign(this.options[opt], options[opt])\n        } else {\n          this.options[opt] = options[opt]\n        }\n      }\n    }\n\n    this.options.clusterIconFunc = this.options.clusterIconFunc || this._clusterIconFunc\n    this.options.pointIconFunc = this.options.pointIconFunc || this._pointIconFunc\n\n    this._keptPointIds = []\n\n    this._initWorker()\n  },\n  /**\n   * @override\n   */\n  onAdd (map) {\n    this._map = map\n\n    if (!this.options.supercluster.maxZoom) {\n      this.options.supercluster.maxZoom = this._map.getMaxZoom()\n\n      if (!this.options.showClustersOnMaxZoom) {\n        this.options.supercluster.maxZoom = this._map.getMaxZoom() - this.options.showMarkersBeforeMaxZoom\n      }\n    }\n\n    if (!this.options.supercluster.minZoom) {\n      this.options.supercluster.minZoom = this._map.getMinZoom()\n    }\n\n    this._createGeoJsonLayer()\n    this._geoJsonLayer.addTo(this._map)\n\n    this._map.on('zoomend', this._zoomEnd, this)\n    this._map.on('moveend', this._moveEnd, this)\n\n    this._clusteringData()\n  },\n  /**\n   * @override\n   */\n  onRemove (map) {\n    map.off('zoomend', this._zoomEnd, this)\n    map.off('moveend', this._moveEnd, this)\n\n    this._geoJsonLayer.clearLayers()\n  },\n  _updateMarkersInOpenedClusterLayer (layer) {\n    if (!layer._openedClusterLayer) {\n      return\n    }\n\n    // refresh all markers\n    const clusterId = layer.feature.properties.cluster_id\n    this._sendMessage('pointsInCluster', {\n      clusterId\n    })\n  },\n  _closeCluster (layer) {\n    this._recursiveRemoveAllOpenedClusterLayer(layer)\n\n    this._removeClassFromIcon(layer, 'opened')\n  },\n  _updateMarkersInCluster (parentLayer, features, legs) {\n    // create map from exist features\n    const featureIdMap = {}\n\n    const len = features.length\n    for (let i = 0; i < len; i++) {\n      featureIdMap[features[i].properties.id] = features[i]\n    }\n\n    // update or remove marker positions\n    const subLayers = parentLayer._openedClusterLayer.getLayers()\n    const subLen = subLayers.length\n    for (let i = 0; i < subLen; i++) {\n      const l = subLayers[i]\n      const id = l.feature.properties.id\n\n      if (featureIdMap[id]) {\n        l.setLatLng(\n          new L.LatLng(featureIdMap[id].geometry.coordinates[1], featureIdMap[id].geometry.coordinates[0])\n        )\n        l.feature = featureIdMap[id]\n        this.fire('layer.updated', {layer: l})\n\n        // try to update data in subcluster\n        if (l._openedClusterLayer && l.feature.properties.features) {\n          // create spiral or subcluster in subcluster\n          const {segmentalFeatures, legs} = this._segmentFeaturesForLayer(l, l.feature.properties.features)\n\n          this._updateMarkersInCluster(l, segmentalFeatures, legs)\n        } else {\n          // if in new markers not segments - remove\n          this._recursiveRemoveAllOpenedClusterLayer(l)\n\n          // mark as closed\n          this._removeClassFromIcon(l, 'opened')\n        }\n\n        // if marker updated - remove from map\n        delete featureIdMap[id]\n      } else {\n        this._recursiveRemoveAllOpenedClusterLayer(l)\n        parentLayer._openedClusterLayer.removeLayer(l)\n      }\n    }\n\n    // insert markers which not exist in subLayers\n    const featuresForCreate = Object.values(featureIdMap)\n\n    parentLayer._openedClusterLayer.addData([\n      ...featuresForCreate, ...legs\n    ])\n  },\n  _createMarkersInCluster (parentLayer, features, legs) {\n    parentLayer._openedClusterLayer = L.geoJson([\n      ...features, ...legs\n    ], {\n      pointToLayer: this._pointToLayer.bind(this),\n      // we draw line from cluster center to point set style for that\n      style: this.options.legsStyle\n    }).addTo(this._map)\n\n    parentLayer._openedClusterLayer.on('click', ({layer}) => {\n      // detect is a point\n      if (layer instanceof L.Marker) {\n        if (layer.feature.properties.subCluster) {\n          this._toggleSubCluster(layer)\n        } else {\n          this._onPointClick(parentLayer, layer)\n        }\n      }\n      // else it could be path to points\n    })\n  },\n  _recursiveRemoveAllOpenedClusterLayer (l) {\n    if (l._openedClusterLayer)  {\n      const layers = l._openedClusterLayer.getLayers()\n      layers.forEach(subL => {\n        this._recursiveRemoveAllOpenedClusterLayer(subL)\n        l._openedClusterLayer.removeLayer(subL)\n      })\n\n      this._map.removeLayer(l._openedClusterLayer)\n      l._openedClusterLayer = null\n    }\n  },\n  _toggleSubCluster (layer) {\n    if (layer._openedClusterLayer) {\n      this._closeSubCluster(layer)\n    } else {\n      this._openSubCluster(layer, layer.feature.properties.features)\n    }\n  },\n  _openCluster ({clusterId, features}) {\n    const layers = this._geoJsonLayer.getLayers()\n\n    const parentLayer = layers.find(l => l.feature.properties.cluster_id === clusterId)\n    if (!parentLayer) {\n      return\n    }\n\n    const {segmentalFeatures, legs} = this._segmentFeaturesForLayer(parentLayer, features)\n\n    if (parentLayer._openedClusterLayer) {\n      this._updateMarkersInCluster(parentLayer, segmentalFeatures, legs)\n    } else {\n      this._createMarkersInCluster(parentLayer, segmentalFeatures, legs)\n    }\n\n    this._addClassToIcon(parentLayer, 'opened')\n  },\n  _closeSubCluster (parentLayer) {\n    if (!parentLayer._openedClusterLayer) {\n      return\n    }\n\n    this._map.removeLayer(parentLayer._openedClusterLayer)\n    parentLayer._openedClusterLayer = null\n\n    this._removeClassFromIcon(parentLayer, 'opened')\n  },\n  _openSubCluster (parentLayer, features) {\n    const {segmentalFeatures, legs} = this._segmentFeaturesForLayer(parentLayer, features)\n\n    if (parentLayer._openedClusterLayer) {\n      this._updateMarkersInCluster(parentLayer, segmentalFeatures, legs)\n    } else {\n      this._createMarkersInCluster(parentLayer, segmentalFeatures, legs)\n    }\n\n    this._addClassToIcon(parentLayer, 'opened')\n  },\n  _getDistanceFromMapCenter () {\n    const center = this._map.getCenter()\n    const bounds =  this._map.getBounds()\n\n    const centerEast = L.latLng(center.lat, bounds.getEast())\n    const distCenterToEast = center.distanceTo(centerEast)\n\n    const centerNorth = L.latLng(bounds.getNorth(), center.lng)\n    const distCenterToNorth = center.distanceTo(centerNorth)\n\n    const distMin = distCenterToEast > distCenterToNorth ? distCenterToNorth : distCenterToEast\n\n    this.options.log && console.log({distCenterToEast, distCenterToNorth, distMin})\n\n    return {distCenterToEast, distCenterToNorth, distMin}\n  },\n  _segmentFeaturesForLayer (parentLayer, features) {\n    const parentCenter = parentLayer.getLatLng()\n\n    const segmentalFeatures = this._segmentFeatures(features, parentCenter)\n\n    const legs = this._getLegsForMarkersInCluster(parentCenter, segmentalFeatures)\n\n    return {segmentalFeatures, legs}\n  },\n  _segmentFeatures (features, parentCenter) {\n    // we need to align data by id sor saving order\n    // and prevent popup rotate\n    features.sort((a, b) => {\n      if (a.properties.id > b.properties.id) {\n        return 1\n      }\n      if (a.properties.id < b.properties.id) {\n        return -1\n      }\n      return 0\n    })\n\n    const len = features.length\n    const maxMarkersInClusterOnOnePoint = this.options.maxMarkersInClusterOnOnePoint\n    const subClusterCount = Math.ceil(len / maxMarkersInClusterOnOnePoint)\n\n    if (len <= maxMarkersInClusterOnOnePoint) {\n      return this._createSpiral(features, parentCenter)\n    }\n\n    // build points for subcluster\n    const subClusters = []\n    for (let i = 0; i < subClusterCount; i++) {\n      const featuresInSubCluster = features.slice(i * maxMarkersInClusterOnOnePoint, (i + 1) * maxMarkersInClusterOnOnePoint)\n      subClusters.push({\n        type: 'Feature',\n        properties: {\n          id: `sub_${i}`,\n          subCluster: true,\n          point_count: featuresInSubCluster.length,\n          features: featuresInSubCluster\n        },\n        geometry: {\n          type:'Point',\n          coordinates: []\n        }\n      })\n    }\n\n    return this._createSpiral(subClusters, parentCenter, true)\n  },\n  /**\n   * @source https://github.com/Leaflet/Leaflet.markercluster/blob/74c766be3aa962a062010b520ca9c982bd13cfb0/src/MarkerCluster.Spiderfier.js#L74\n   */\n  _createSpiral (features, parentCenter, isSubCluster = false) {\n    const spiralLengthFactor = 5\n    const spiderfyDistanceMultiplier = this.options.spiderfyDistanceMultiplier * (isSubCluster ? this.options.showedSubClusterMultiplier : 1)\n    const spiralFootSeparation = 28\n    const spiralLengthStart = 11\n\n    const centerPt = this._map.latLngToLayerPoint(parentCenter)\n\n    const pi2 = Math.PI * 2\n    const count = features.length\n    const separation = spiderfyDistanceMultiplier * spiralFootSeparation\n    const lengthFactor = spiderfyDistanceMultiplier * spiralLengthFactor * pi2\n    let legLength = spiderfyDistanceMultiplier * spiralLengthStart\n    let angle = 0\n    let i\n    let p\n    let coords\n\n    const newFeatures = []\n\n    // Higher index, closer position to cluster center.\n    for (i = count; i >= 0; i--) {\n      // Skip the first position, so that we are already farther from center and we avoid\n      // being under the default cluster icon (especially important for Circle Markers).\n      if (i < count) {\n        p = new L.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle))._round()\n        coords = this._map.layerPointToLatLng(p)\n        features[i].geometry.coordinates = [\n          coords.lng,\n          coords.lat,\n        ]\n        newFeatures.push(features[i])\n      }\n      angle += separation / legLength + i * 0.0005\n      legLength += lengthFactor / angle\n    }\n    return newFeatures\n  },\n  _getLegsForMarkersInCluster (parentCenter, features) {\n    const parentCenterGeometry = [parentCenter.lng, parentCenter.lat]\n\n    const legs = []\n    const len = features.length\n    for (let i = 0; i < len; i++) {\n      legs.push({\n        type: 'LineString',\n        coordinates: [\n          features[i].geometry.coordinates, parentCenterGeometry\n        ]\n      })\n    }\n\n    return legs\n  },\n  _addClassToIcon (l, name) {\n    if (l._icon && l._icon.classList) {\n      l._icon.classList.add(name)\n    }\n  },\n  _removeClassFromIcon (l, name) {\n    if (l._icon && l._icon.classList) {\n      l._icon.classList.remove(name)\n    }\n  }\n})\n\n"],"sourceRoot":""}